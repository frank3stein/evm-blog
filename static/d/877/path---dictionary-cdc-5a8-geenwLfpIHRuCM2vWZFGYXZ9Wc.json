{"data":{"site":{"siteMetadata":{"title":null,"author":null}},"mdx":{"id":"0a8fe7e2-ee18-5d43-bcf6-7469975a0c97","excerpt":"Dictionary 5 types of primitives boolean number string null //typeof = object, but it should be null undefined #Test repl #Declaring Variables and Hoisting Both…","frontmatter":{"title":"Dictionary (draft)","date":"November 26, 2018"},"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nconst layoutProps = {};\nreturn class MDXContent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.layout = null;\n  }\n\n  render() {\n    const _this$props = this.props,\n          {\n      components\n    } = _this$props,\n          props = _objectWithoutProperties(_this$props, [\"components\"]);\n\n    return React.createElement(MDXTag, {\n      name: \"wrapper\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"h1\",\n      components: components\n    }, `Dictionary`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `5 types of primitives`), React.createElement(MDXTag, {\n      name: \"ul\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, `boolean`), React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, `number`), React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, `string`), React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, `null //typeof = object, but it should be null`), React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, `undefined`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `#Test repl`), React.createElement(\"iframe\", {\n      height: \"1000px\",\n      width: \"100%\",\n      src: \"https://repl.it/@martinezi/bubble-sort-exercise-prompt?lite=true\",\n      scrolling: \"no\",\n      frameborder: \"no\",\n      allowtransparency: \"true\",\n      allowfullscreen: \"true\",\n      sandbox: \"allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals\"\n    }), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `#Declaring Variables and Hoisting`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `var f\n\nglobal.f\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Both works but var has an advantage of clearly conveying the effect on program’s scope. To avoid errors always declare locally.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `When a variable is declared, it is hoisted. The reference to the variable is bound to the nearest scope, in which the variable was declared.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `No block scope until es2016\nlet is block scoped.\n#Closure\n#Scope\n#Functions\n`, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `Function declaration`), ` defines a function and binds it to a variable in the `, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `current`), ` scope.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"https://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/\"\n      }\n    }, `Function Expressions vs Function Declarations`)), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `function double(x) {\n  return x * 2\n}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Above example could be turned into a `, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `named function expression`), ` if it is bound to a variable:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `var f = function double(x) {\n  return x * 2\n}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `In the first example function is declared as `, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"strong\"\n    }, `double`)), ` in the function (global scope, unless imported into another fucntion). Function declaration is hoisted.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `In the latter example, function is bound to the variable `, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"strong\"\n    }, `f`)), `. Declared variable is hoisted, but function expression is not.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `We can also write it as `, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `anonymous function expression`), `:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `var f = function(x) {\n  return x * 2\n}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `Named vs Anonymous function expression`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Named\nBoth of the functions are only available in the function scope, so in order to use them recursively, they can be called by the name inside the function:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `var f = function name() {\n  return name()\n  // Will fail because calls itself indefinitely.\n}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `But when name function is called in the global scope it will be undefined as it only lives within the function closure.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `The variable f is also available in the function body, so in the case of anonymous functions, f can be used to call the function recursively.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `.call`), `\nIn the function constructor.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `The function behaves similarly, but the first parameter allows you to define the receiver object explicitly.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `dictionary example\nhasOwnProperty method does not exist in dictionary.\nBut by using call we can access it`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `var hasOwnProperty = {}.hasOwnProperty\ndict.foo = 1\nhasOwnProperty.call(dict, 'foo') //true\nhasOwnProperty.call(dict, 'hasOwnProperty') //false\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `.apply`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Variadic o Variable-arity function : It can take any number of arguments.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Apply takes an array of arguments and calls the function as if each element of the array were an individual argument for the call. Additionally you can set this explicitly with the first argument. If this is not going to be used you can pass in null.`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `average(arg1, arg2, ...argn)\n\nvar scores = getAllScores()\naverage.apply(null, scores)\n// If scores have 3 elements\n// average.apply(null, scores); = average(scores[0], scores[1], scores[2]);\n`)), React.createElement(MDXTag, {\n      name: \"ul\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"li\"\n    }, `Use apply to call variadic functions with a computed array of arguments.`)), React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"li\"\n    }, `Use the first argument of apply to provide a receiver for variadic methods.`))), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `Variadic functions`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Variadic functions can be created by using the `, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `arguments`), `.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `fixed-arity vs variable-arity functions`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Lets take averageOfArray as example;`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `// Fixed-arity function\nfunction averageOfArray(a) {\n  for (var i = 0, sum = 0, n = a.length; i < n; i++) {\n    sum += a[i]\n  }\n  return sum / n\n}\n\n//Variable-arity fucntion\nfunction average() {\n  for (var i = 0, sum = 0, n = arguments.length; i < n; i++) {\n    sum += arguments[i]\n  }\n  return sum / n\n}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `One caveat of variable-arity functions is that they loose convenience as they need to be called with apply. To overcome this we can wrap the fixed-arity function by using arguments with the variable-arity function.`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `function average(){\n  return function averageOfArray(arguments);\n}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `This turns variable-arity function into a version with fixed capability without the need of apply function.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `#`, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `arguments`), React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `Never Modify arguments object`), `\nIf needed arguments object could be copied to a real array using`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `var args = [].slice.call(arguments)\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Arguments is nested within the function, so when using f.g.h\ncases if we want to reach the arguments of f in h, we need to create a variable that stores that at f level scope.`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `f(){\n a = arguments;\n g(){\n      h(){\n      a //arguments of a\n      arguments // arguments of h\n      }\n  }\n}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `.bind`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `A function’s receiver is determined by how it is called.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `For example forEach implementation uses the global object as it’s default receiver. Let us look at an example:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `var buffer = {\n  entries: [],\n  add: function(s) {\n    this.entries.push(s)\n  },\n  concat: function() {\n    return this.entries.join('')\n  },\n}\n\nvar source = ['867', '-', '42355']\nsource.forEach(buffer.add) // error: entries is not defined\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Here the receiver of buffer.add is not buffer. We pass the buffer.add function to forEach. In this case, forEach offers an optional argument to use as receiver of its callback.`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `source.forEach(buffer.add, buffer)\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Not all higher order functions provide a receiver for their callbacks. In this case we can create a local function that `, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `calls`), ` buffer.add method from buffer object.`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `source.forEach(function(s) {\n  buffer.add(s)\n})\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `In this case we call buffer.add appropriately as a method of the object in a wrapper function. No matter how the wrapper function function(s){} is called, since inside it is called as a method of its parent object, it pushes its arguments inside buffer.entries.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Since the need to use this pattern was so common, in ES5 it was added to the library as .bind.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `!! buffer.add.bind(`, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `buffer`), `) creates a new function just like the old one , but with its receiver bound to `, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `buffer`), ` (.bind(`, React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `buffer`), `)).`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Since it is a new function`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `buffer.add === buffer.add.bind(buffer) //false\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `This is a crucial point;`), ` It means bind is safe to call even on a function that may be shared by other parts of a program. It is especially important for methods shared on a prototype object: the method will still work correctly when called on any of the prototype’s descendants.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `Using .bind to curry functions`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `An example function, constructing urls`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `function simpleURL(protocol, domain, path) {\n  return protocol + '://' + domain + '/' + path\n}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Let us assume we use this to create absolute URLS for our website:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `var urls = paths.map(function(path) {\n  return simpleURL('http', siteDomain, path)\n})\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `For each iteration of the map higher order function, we use same first two arguments. They are fixed for our urls.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `We can use bind method on simpleURL to construct this function without a wrapper function.`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `var urls = paths.map(simpleURL.bind(null, 'http', siteDomain))\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Remember .map higher order function passes each element of the array into the function inside, simpleURL, as an argument. So in this case it is`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `simpleURL(path).bind(null, 'http', siteDomain)\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `inside map function. The arguments after receiver object(first bind argument), are prepended to simpleURL arguments, so in effect the function above delegates to`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `simpleURL('http', siteDomain, path)\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `The call to simpleURL.bind produces a new function that deletages to simpleURL.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `This technique of binding a function to a subset of its arguments is known as currying, named after the logician Haskell Curry.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `With currying you can implement function delegation without explicit wrapper functions.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `#Objects and Prototypes`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `// Reserved`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"http://javascriptissexy.com/javascript-objects-in-detail/\"\n      }\n    }, `http://javascriptissexy.com/javascript-objects-in-detail/`), React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `in`), ` all properties show, inherited and own\nTo find out if a property exists on an object (either as an inherited or an own property), you use the in operator:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `// Create a new school object with a property name schoolName\nvar school = { schoolName: 'MIT' }\n\n// Prints true because schoolName is an own property on the school object\nconsole.log('schoolName' in school) // true\n\n// Prints false because we did not define a schoolType property on the school object, and neither did the object inherit a schoolType property from its prototype object Object.prototype.\nconsole.log('schoolType' in school) // false\n\n// Prints true because the school object inherited the toString method from Object.prototype.\nconsole.log('toString' in school) // true\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `hasOwnProperty`), ` only own properties show.\nTo find out if an object has a specific property as one of its own property, you use the hasOwnProperty method. This method is very useful because from time to time you need to enumerate an object and you want only the own properties, not the inherited ones.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `get\nset`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `In object literal, the get or set notation for properties allows you to specify a function to be run when the property is read or written.`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-javascript\"\n      }\n    }, `var pile = {\n  elements: ['eggshell', 'orange peel', 'worm'],\n  get height() {\n    return this.elements.length\n  },\n  set height(value) {\n    console.log('Ignoring attempt to set height to', value)\n  },\n}\n\nconsole.log(pile.height)\n// → 3\npile.height = 100\n// → Ignoring attempt to set height to 100\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `#Enumurable`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Properties that show in for … in loops.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Enumerable properties are those properties whose internal [`, `[Enumerable]`, `] flag is set to true, which is the default for properties created via simple assignment or via a property initializer (properties defined via Object.defineProperty and such default [`, `[Enumerable]`, `] to false). Enumerable properties show up in for…in loops unless the property’s name is a Symbol. Ownership of properties is determined by whether the property belongs to the object directly and not to its prototype chain. Properties of an object can also be retrieved in total. There are a number of built-in means of detecting, iterating/enumerating, and retrieving object properties, with the chart showing which are available.`));\n  }\n\n}"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/dictionary/","previous":{"id":"652dcd00-1a30-5413-8e2f-b732562d1b82","fields":{"slug":"/hi-folks/"},"frontmatter":{"title":"New Beginnings"},"code":{"scope":""}},"next":{"id":"8539e5d0-224a-5a85-9421-d882e366c53e","fields":{"slug":"/first-post/"},"frontmatter":{"title":"First post"},"code":{"scope":""}}}}