{"componentChunkName":"component---src-templates-blog-post-js","path":"/string-template-literal/","result":{"data":{"site":{"siteMetadata":{"title":"e v m","author":"Emil Martinov","siteUrl":"https://www.emilmartinov.com"}},"mdx":{"id":"a25b721e-20a9-5cf1-8ef0-7f506975e3b6","excerpt":"Operations with String Literals are very unintuitive. There are a lot of pieces you need to keep in mind. And is error prone.  String template literals  make…","frontmatter":{"title":"String Template Literal","date":"August 11, 2020"},"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nconst layoutProps = {};\nreturn class MDXContent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.layout = null;\n  }\n\n  render() {\n    const _this$props = this.props,\n          {\n      components\n    } = _this$props,\n          props = _objectWithoutProperties(_this$props, [\"components\"]);\n\n    return /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"wrapper\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, /*#__PURE__*/React.createElement(\"h4\", null, `String Template Literal`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Operations with String Literals are very unintuitive. There are a lot of pieces you need to keep in mind. And is error prone. `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `String template literals`), ` make the string literals more readable and reasonable. Here is how we would do the same thing.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `const name = 'Emil';\nconsole.log(\\`\\${name}'s blog\\`);\n`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `By just reading it you can guess what it is doing. `, `\\``, ` the backtick opens and closes the string template literal and inside we can use javascript expressions. Think of string template literals as the superset of template literals, they can do everything a string literal can do and more.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `const a = 5;\nconst b = 10;\nconsole.log(\\`a plus b is \\${a + b}.\\`); // a plus b is 15.\nconsole.log('a plus b is ' + a + b + '.'); // a plus b is 510.\nconsole.log('a plus b is ' + (a + b) + '.'); // a plus b is 15.\n`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Above is another pain point of string literals. Coercion is javascript engine’s attempt to turn your code into a runnable executable. So when you try to concatinate a string with a number, Javacript does not throw an error, but tries to guess what we are trying to do. So it assumes we want to add the number value into the string.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `console.log('1' + 34); // '134'\n`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `So when we do addition with a string with a number with another addition with a number`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `console.log('a plus b is ' + a + b + '.');\n`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `From left to right it just adds the numbers into the string as string values.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `String template literals on the other hand are explicit about what will return exactly.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `console.log(\\`a plus b is \\${a + b}.\\`);\n`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Above we know only after a + b operation is done and returns a value we are going to include it in the string.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `In order to perform the number addition operation first we can use braces.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `console.log('a plus b is ' + (a + b) + '.'); // a plus b is 15.\n`)));\n  }\n\n}"}}},"pageContext":{"slug":"/string-template-literal/","previous":{"id":"13a833b6-c4ff-52d9-ae31-7826bdd14d55","fields":{"slug":"/parameters-vs-arguments/"},"frontmatter":{"title":"Parameters vs Arguments"},"code":{"scope":""}},"next":{"id":"61b79d87-fb4e-5aa7-bc68-8719553dd074","fields":{"slug":"/stack-vs-heap/"},"frontmatter":{"title":"Stack vs Heap"},"code":{"scope":""}}}},"staticQueryHashes":["3128451518","3132601055"]}