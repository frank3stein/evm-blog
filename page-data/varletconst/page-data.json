{"componentChunkName":"component---src-templates-blog-post-js","path":"/varletconst/","result":{"data":{"site":{"siteMetadata":{"title":"e v m","author":"Emil Martinov","siteUrl":"https://www.emilmartinov.com"}},"mdx":{"id":"eb35ef18-15d4-5f9d-bf0f-070b3c9dd16c","excerpt":"In short: var  creates a variable in its scope. Since Javascript does not have block level scope, variable lives in its scope and the variables in any scope can…","frontmatter":{"title":"var, let and const --- (bonus: hoisting)","date":"November 10, 2019"},"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nconst layoutProps = {};\nreturn class MDXContent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.layout = null;\n  }\n\n  render() {\n    const _this$props = this.props,\n          {\n      components\n    } = _this$props,\n          props = _objectWithoutProperties(_this$props, [\"components\"]);\n\n    return /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"wrapper\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `In short:`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"ul\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components,\n      parentName: \"li\"\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `var`), ` creates a variable in its scope. Since Javascript does not have block level scope, variable lives in its scope and the variables in any scope can be accessed . At runtime, Javascript engine hoists variable declarations and initializes them to undefined. Only after the assignment line is reached, then it assigns it to the value.`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components,\n      parentName: \"li\"\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `let`), ` creates a variable in block scope `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `{}`), `. Variables declared inside `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `{}`), ` can not escape the block scope. They are stuck there from the time they are assigned until the bracket closes `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `}`), `. let declarations are hoisted, but they are not initialized like var to undefined. So if you try to use them before they are assigned, you are going to get a reference error. Your code won’t run, it will throw an error.`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components,\n      parentName: \"li\"\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"em\",\n      components: components,\n      parentName: \"p\"\n    }, `const`), ` creates a variable in block scope `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `{}`), `, just like let. The only difference from let is, it can not be reassigned. But not as you would expect. If const is assigned to a primitive value, it can not be reassigned, it is immutable, Javascript engine will not let you change that value. But if you assign a data structure to it, like `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `[array]`), ` or `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `{object}`), `. You can change the contents of that object. The reason for this is simple and elegant, the data structures are dynamic, so their size is not predetermined. The Javascript engine makes no assumption of how large or small an array or object can be. That is why, the reference to that object is immutable but the object itself is not.`))), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"hr\",\n      components: components\n    }), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `For example, consider you have two users with exact same name and the surname.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `const user1 = {\n  name: 'Emil',\n  lastName: 'Martinov',\n};\n\nconst user2 = {\n  name: 'Emil',\n  lastName: 'Martinov',\n};\n`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Javascript only allocates one place for primitive values in the memory. Every word in the English language can be constructed by combining the letters of the alphabet. So the engine just has to keep the letters in memory and it can easily create any word by combining the adresses of these letters in specific order. For each unique word it has to do it only once, and once it saves it in the memory, it can retrive it whenever it wants from that address. So the value of ‘Emil’ in the memory is a combination of ordered characters E, m, i and l. Both of `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `user1.name`), ` and `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `user2.name`), ` points to the same location in memory. Even if you had created thousand variables with the value ‘Emil’, each will point to same location in the memory and each one of them will be equal to another. In this sense, for primitive values`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `These is not true for the objects. In javascript objects and arrays are dynamic, they can change shape, can get bigger or smaller. So the engine has no way of knowing how much memory an object needs. So it can not make any assumptions. Instead it creates a new space for each object, even if they look exactly the same, with the same values. JS engine does not know if or when they will change.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `user1 === user2; //false\nuser1.name === user2.name; // true\n`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"hr\",\n      components: components\n    }), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `A little deep dive to why here`), `. In Javascript, data structures like objects and arrays are dynamic. Fancy way of saying, you can change them. This comes at the cost of speed compared to languages where you need to predefine size and the shape of the structure.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Imagine you are a librarian that you only had one bookshelf, and each time someone brought back a book, the book could get as big as the shelf itself or just be as small as the paper. When the books get bigger you could cut them to small pieces to fit it back in the bookshelf, and put them back each time someone requests it, but that will take a lot of time. To fit the books on the shelf, you would need to reshuffle them, whcih will take less time but much more time then when the books’ size is set. They will never change, so you know exactly where to put them and they will stay there. This makes your job much faster.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `On the other hand, with primitive values, you only need to keep the building blocks in memory. So for any number imaginable (ok memory has its limits, but let us think it does not), you only have to have numbers from 0 to 9. You can create the rest from the combinations of them. For example 12312481241249012. Once you save this number in memory, you can use that exact same number that sits in the same memory place.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `Inside code block // is followed by {value of the line}`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `const couch = {\n  name: 'couch',\n  size: 1,\n};\nlet myFirstCouch = couch;\ncouch.size = 2;\nconsole.log(myFirstCouch.size); // 2\nconsole.log(myFirstCouch === couch); // true\n\nconst notMyCouch = {\n  /* identical values with myFirstCouch */\n  name: 'couch',\n  size: 1,\n};\nconsole.log(myFirstCouch === notMyCouch); // false\n\n/*Primitive values*/\nconst bigNumber = 12312481241249012;\nconst sameBigNumber = 12312481241249012;\nbigNumber = 1; // this will be a type error.\"Uncaught TypeError: Assignment to constant variable.\" You will need to remove this line so the code runs\nlet anotherCopyOfBigNumber = 12312481241249012;\n\nconsole.log(bigNumber === anotherCopyOfBigNumber); // true\nconsole.log(bigNumber === sameBigNumber); // true\n`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"hr\",\n      components: components\n    }), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Let us look at some code.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `console.log(avariableWhichIsNotDefined); // It will throw. \"Uncaught ReferenceError: avariableWhichIsNotDefined is not defined\". Careful here it says is not defined, not undefined. Those have different meaning.\nprintMyName('Emil'); // Emil\nconsole.log(name); // undefined.\n\n/*variable declaration name assigned to primitive value 'Emil'*/\nvar name = 'Emil';\nname = 'Kevin';\nconsole.log(name, surname); // Kevin undefined\nvar surname = 'Martinov';\nconsole.log(name, surname); // Kevin Martinov\n/*function declaration printMyName*/\nfunction printMyName(name) {\n  console.log(name);\n}\n`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `This is the code we had written and now we will run it. (see next code block to see how javascript engine runs it.)`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `First, Javascript engine hoists variable and function declarations (`, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `printMyName`), ` is a function declaration) at first run, and it initializes variable declarations with `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `undefined`), `. Initializing means that the engine assigns them to undefined, for example `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `var name = undefined`), `.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Function declarations are hoisted as a whole. So even if they are defined at the bottom of the file, you can call them at the first line of your code. After this first run is finished, Javascript engine starts to run the code as business as usual, go line by line and execute. Take a look at how the code is after the first run;`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `var name = undefined; //hoisted and initialised with undefined assignment\nvar surname = undefined; //hoisted and initialised with undefined assignment\nfunction printMyName(name) {\n  console.log(name);\n}\n/*Hoisting finishes*/\nprintMyName('Emil'); // Emil\nconsole.log(name); // undefined\nname = 'Emil';\nname = 'Kevin';\nconsole.log(name, surname); // Kevin undefined\n`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Congratualtions ! Now you know how hoisting works for variables and functions. If you assign a function declaration to a variable, function declaration becomes an expression, and it is treated as any other value. The variable declaration is hoisted and assigned to undefined and only after comes to where it is assigned, then it can be used.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `If scope can be thought as a room and hoisting as baloons rising to the top of the room, !! Root from the ceiling to down. Every branch has access to the root.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `So you might think, why do we even use var, if the engine itself is doing this process why extra effort. It gets a bit tricky when you introduce scope into this equation. And remember, Javascript does not have block `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `{}`), ` scope but it has function scope. What ever inside a function has no acces to other, but the function scope itself.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `var name = 'Emil';\nfunction getUserName(name) {\n  function lowerCaseUserName(name) {}\n}\n`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `The web was designed to share documents between people. The main content for it is the text. So for the web the priority is getting the text content to the other person.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Javascript was designed for the web. In that sense it is very forgiving of its writers, it wants to run the page and show the content. Think of it as a flag carrier who won’t drop the flag, although he was shot numerously. It won’t quit its duty no matter what. That is why it is so forgiving.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `When you`));\n  }\n\n}"}}},"pageContext":{"slug":"/varletconst/","previous":{"id":"e4438c73-f524-523c-b690-1a62dbb297b6","fields":{"slug":"/scope-&&-closure/"},"frontmatter":{"title":"Scope && Closure"},"code":{"scope":""}},"next":{"id":"3b6ec9b2-16e8-5157-ab98-237576c07762","fields":{"slug":"/functions/"},"frontmatter":{"title":"Functions"},"code":{"scope":""}}}},"staticQueryHashes":["3128451518","3132601055"]}