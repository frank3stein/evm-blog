{"componentChunkName":"component---src-templates-blog-post-js","path":"/parameters-vs-arguments/","result":{"data":{"site":{"siteMetadata":{"title":"e v m","author":"Emil Martinov","siteUrl":"https://www.emilmartinov.com"}},"mdx":{"id":"13a833b6-c4ff-52d9-ae31-7826bdd14d55","excerpt":"Functions have to states, a definition and invocation state.  In the definition state, the engine reads the function definition and assigns it to a variable forâ€¦","frontmatter":{"title":"Parameters vs Arguments","date":"August 11, 2020"},"code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nconst layoutProps = {};\nreturn class MDXContent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.layout = null;\n  }\n\n  render() {\n    const _this$props = this.props,\n          {\n      components\n    } = _this$props,\n          props = _objectWithoutProperties(_this$props, [\"components\"]);\n\n    return /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"wrapper\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Functions have to states, a definition and invocation state. `), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `In the definition state, the engine reads the function definition and assigns it to a variable for a later call. `), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `In invocation state, we call the function and let it do its work. Unless the function is called, inside `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `{}`), ` of the function is not executed. So while reading it, you can ignore it completely, till you come to the line of code where it is executed. Only then the recipe of the function, its definition, becomes relavent. `), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `function declaration(name){ // the function is declared\n    return \\`The \\${name} just ran.\\`;\n}\nconsole.log(declaration(\\`test function\\`))// the function is called\n`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `In the above example, while the function is declared, the input name is refered to as `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `parameter`), `. `), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `When the declaration function is ran inside console.log function, `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `test function`), ` is called an `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `argument`), `.`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `The difference is slight but important. We as developers work in teams and we must communicate our intent to our collagues, and in order to do that effectively, we must be able to communicate in detail. `), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `For example compare these 2 sentences,`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"ul\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components,\n      parentName: \"li\"\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `The function has 2 parameters, name and age`))), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components,\n      parentName: \"li\"\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `The function has 2 arguments, name and age`)))), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Without any other context, since we know parameters are in definition phase we know that the `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `first case`), ` is something like this`), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `function someFunction(name, age){\n    //..... some function\n}\n`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `and the `, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `second case`), ` is `), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `someFunction(name, age)\n`)), /*#__PURE__*/React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `The why of arguments and parameters is for effective communication. This becomes even more valuable when we are seeking help and asking a technical question, in Stackoverflow, Google or creating an issue on Github.`));\n  }\n\n}"}}},"pageContext":{"slug":"/parameters-vs-arguments/","previous":{"id":"61b79d87-fb4e-5aa7-bc68-8719553dd074","fields":{"slug":"/stack-vs-heap/"},"frontmatter":{"title":"Stack vs Heap"},"code":{"scope":""}},"next":null}},"staticQueryHashes":["3128451518","3132601055"]}