{"version":3,"sources":["webpack:///./node_modules/acorn/dist/acorn.es.js"],"names":["reservedWords","3","5","6","strict","strictBind","ecma5AndLessKeywords","keywords","keywordRelationalOperator","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","RegExp","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","code","set","pos","i","length","isIdentifierStart","astral","test","String","fromCharCode","isIdentifierChar","TokenType","label","conf","this","keyword","beforeExpr","startsExpr","isLoop","isAssign","prefix","postfix","binop","updateContext","name","prec","keywords$1","kw","options","types","num","regexp","string","eof","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","arrow","template","invalidTemplate","ellipsis","backQuote","dollarBraceL","eq","assign","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","starstar","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","lineBreak","lineBreakG","source","isNewLine","ecma2019String","nonASCIIwhitespace","skipWhiteSpace","ref","Object","prototype","hasOwnProperty","toString","has","obj","propName","call","isArray","Array","Position","line","col","column","offset","n","SourceLocation","p","start","end","sourceFile","getLineInfo","input","cur","lastIndex","match","exec","index","defaultOptions","ecmaVersion","sourceType","onInsertedSemicolon","onTrailingComma","allowReserved","allowReturnOutsideFunction","allowImportExportEverywhere","allowAwaitOutsideFunction","allowHashBang","locations","onToken","onComment","ranges","program","directSourceFile","preserveParens","plugins","getOptions","opts","opt","tokens","token","push","array","block","text","startLoc","endLoc","comment","type","value","loc","range","pushComment","keywordRegexp","words","replace","Parser","startPos","reserved","v","reservedStrict","reservedWordsStrict","reservedWordsStrictBind","containsEsc","loadPlugins","lineStart","lastIndexOf","curLine","slice","split","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","context","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","inFunction","inGenerator","inAsync","yieldPos","awaitPos","labels","skipLineComment","scopeStack","enterFunctionScope","regexpState","isKeyword","word","isReservedWord","extend","f","pluginConfigs","plugin","Error","parse","node","startNode","nextToken","parseTopLevel","pp","literal","DestructuringErrors","shorthandAssign","trailingComma","parenthesizedAssign","parenthesizedBind","doubleProto","eat","next","isContextual","eatContextual","expectContextual","unexpected","canInsertSemicolon","insertSemicolon","semicolon","afterTrailingComma","tokType","notNext","expect","raise","checkPatternErrors","refDestructuringErrors","raiseRecoverable","parens","checkExpressionErrors","andThrow","checkYieldAwaitInDefaultParams","isSimpleAssignTarget","expr","expression","pp$1","exports","body","stmt","parseStatement","adaptDirectivePrologue","finishNode","loopLabel","kind","switchLabel","isLet","skip","nextCh","charCodeAt","ident","isAsyncFunction","charAt","declaration","topLevel","starttype","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseFunctionStatement","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","parseImport","parseExport","maybeName","parseExpression","parseLabeledStatement","parseExpressionStatement","isBreak","parseIdent","lab","pop","parseParenExpression","awaitAt","enterLexicalScope","parseFor","init$1","parseVar","declarations","init","await","parseForIn","toAssignable","checkLVal","isAsync","parseFunction","consequent","alternate","argument","discriminant","cases","sawDefault","isCase","exitLexicalScope","empty","handler","clause","param","parseBindingAtom","finalizer","object","i$1","list","label$1","statementStart","generator","async","createNewLexicalScope","update","id","left","right","parseMaybeAssign","isFor","decl","parseVarId","isStatement","allowExpressionBody","initFunction","oldInGen","oldInAsync","oldYieldPos","oldAwaitPos","oldInFunc","parseFunctionParams","parseFunctionBody","params","parseBindingList","parseClassId","parseClassSuper","classBody","hadConstructor","member","parseClassMember","this$1","method","tryContextual","k","noLineBreak","key","computed","startNodeAt","static","isGenerator","parsePropertyName","parseClassMethod","parseMethod","superClass","parseExprSubscripts","parseExprAtom","checkExport","fNode","cNode","shouldParseExportStatement","checkVariableExport","specifiers","parseExportSpecifiers","spec","checkUnreserved","local","checkPatternExport","pat","properties","prop","list$1","elements","elt","decls","nodes","first","exported","parseImportSpecifiers","node$1","node$2","imported","statements","isDirectiveCandidate","directive","raw","statement","pp$2","isBinding","toAssignableList","operator","exprList","last","parseSpread","parseRestBinding","parseObj","close","allowEmpty","allowTrailingComma","elts","rest","parseBindingListItem","elem","parseMaybeDefault","bindingType","checkClashes","canDeclareVarName","canDeclareLexicalName","declareVarName","declareLexicalName","pp$3","checkPropClash","propHash","shorthand","proto","other","get","noIn","expressions","afterLeftParse","parseYield","ownDestructuringErrors","oldParenAssign","oldTrailingComma","parseMaybeConditional","parseExprOps","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","logical","op","buildBinary","sawUnary","parseAwait","skipArrowSubscripts","result","parseSubscripts","base","noCalls","maybeAsyncArrow","property","parseExprList","parseArrowExpression","callee","arguments","tag","quasi","parseTemplate","isTagged","canBeArrow","parseLiteral","regex","pattern","flags","parseParenAndDistinguishExpression","parseNew","val","spreadStart","innerStartPos","innerStartLoc","lastIsComma","parseParenItem","innerEndPos","innerEndLoc","parseParenArrowList","finishNodeAt","par","item","empty$1","meta","parseTemplateElement","cooked","tail","curElt","quasis","isAsyncProp","isPattern","parseProperty","parsePropertyValue","paramCount","isArrowFunction","isExpression","oldStrict","useStrict","checkParams","nonSimple","isSimpleParamList","oldLabels","exitFunctionScope","allowDuplicates","nameHash","indexOf","liberal","delegate","pp$4","message","err","SyntaxError","raisedAt","pp$5","target","sources","len","var","lexical","childVar","parentLexical","parentScope","childScope","currentScope","Node","parser","pp$6","TokContext","isExpr","preserveSpace","override","types$1","b_stat","b_expr","b_tmpl","p_stat","p_expr","q_tmpl","tryReadTemplateToken","f_stat","f_expr","f_expr_gen","f_gen","pp$7","braceIsBlock","prevType","parent","curContext","inGeneratorContext","out","statementParens","allowed","data","apply","$LONE","General_Category","gc","sc","Script_Extensions","scx","Script","pp$9","RegExpValidationState","validFlags","switchU","switchN","lastIntValue","lastStringValue","lastAssertionIsQuantifiable","numCapturingParens","maxBackReference","groupNames","backReferenceNames","codePointToString$1","ch","isSyntaxCharacter","isControlLetter","isUnicodePropertyNameCharacter","isUnicodePropertyValueCharacter","isDecimalDigit","isHexDigit","hexToInt","isOctalDigit","reset","unicode","at","s","l","c","nextIndex","current","lookahead","advance","validateRegExpFlags","state","flag","validateRegExpPattern","regexp_pattern","regexp_disjunction","regexp_alternative","regexp_eatQuantifier","regexp_eatTerm","regexp_eatAssertion","regexp_eatAtom","regexp_eatExtendedAtom","lookbehind","noError","regexp_eatQuantifierPrefix","regexp_eatBracedQuantifier","min","max","regexp_eatDecimalDigits","regexp_eatPatternCharacters","regexp_eatReverseSolidusAtomEscape","regexp_eatCharacterClass","regexp_eatUncapturingGroup","regexp_eatCapturingGroup","regexp_eatAtomEscape","regexp_groupSpecifier","regexp_eatInvalidBracedQuantifier","regexp_eatExtendedPatternCharacter","regexp_eatSyntaxCharacter","regexp_eatGroupName","regexp_eatRegExpIdentifierName","regexp_eatRegExpIdentifierStart","regexp_eatRegExpIdentifierPart","regexp_eatRegExpUnicodeEscapeSequence","isRegExpIdentifierStart","isRegExpIdentifierPart","regexp_eatBackReference","regexp_eatCharacterClassEscape","regexp_eatCharacterEscape","regexp_eatKGroupName","regexp_eatDecimalEscape","regexp_eatControlEscape","regexp_eatCControlLetter","regexp_eatZero","regexp_eatHexEscapeSequence","regexp_eatLegacyOctalEscapeSequence","regexp_eatIdentityEscape","regexp_eatControlLetter","regexp_eatFixedHexDigits","lead","leadSurrogateEnd","trail","regexp_eatHexDigits","isCharacterClassEscape","regexp_eatUnicodePropertyValueExpression","regexp_eatUnicodePropertyName","regexp_eatUnicodePropertyValue","regexp_validateUnicodePropertyNameAndValue","regexp_eatLoneUnicodePropertyNameOrValue","nameOrValue","regexp_validateUnicodePropertyNameOrValue","regexp_classRanges","regexp_eatClassAtom","regexp_eatClassEscape","ch$1","regexp_eatClassControlLetter","regexp_eatOctalDigit","n1","n2","Token","pp$8","codePointToString","getToken","Symbol","iterator","done","skipSpace","finishToken","readToken","fullCharCodeAtPos","readWord","getTokenFromCode","skipBlockComment","startSkip","loop","readToken_dot","readNumber","next2","readToken_slash","readRegexp","finishOp","readToken_mult_modulo_exp","size","tokentype","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readRadixNumber","readString","str","escaped","inClass","flagsStart","readWord1","e","readInt","radix","total","Infinity","startsWithDot","octal","parseInt","parseFloat","readCodePoint","codePos","readHexChar","invalidStringToken","quote","chunkStart","readEscapedChar","INVALID_TEMPLATE_ESCAPE_ERROR","inTemplateElement","readTmplToken","readInvalidTemplateToken","position","inTemplate","octalStr","substr","escStart","esc","parse_dammit","LooseParser","pluginsLoose","version","parseExpressionAt","tokenizer","addLooseExports","Parser$$1","plugins$$1"],"mappings":"6FAAA,4qCACA,IAAIA,EAAgB,CAClBC,EAAG,sNACHC,EAAG,+CACHC,EAAG,OACHC,OAAQ,yEACRC,WAAY,kBAGVC,EAAuB,8KACvBC,EAAW,CACbL,EAAGI,EACHH,EAAGG,EAAuB,4CAExBE,EAA4B,kBAO5BC,EAA+B,86BAC/BC,EAA0B,ijBAC1BC,EAA0B,IAAIC,OAAO,IAAMH,EAA+B,KAC1EI,EAAqB,IAAID,OAAO,IAAMH,EAA+BC,EAA0B,KACnGD,EAA+BC,EAA0B,KAOzD,IAAII,EAA6B,CAAC,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,IAAK,GAAI,GAAI,IAAK,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,IAAK,IAAK,GAAI,GAAI,GAAI,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,EAAG,EAAG,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,IAAK,GAAI,GAAI,EAAG,IAAK,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,GAAI,IAAK,KAAM,KAAM,KAAM,IAAK,KAAM,IAAK,EAAG,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,IAAK,GAAI,IAAK,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,KAAM,GAAI,IAAK,KAAM,IAAK,GAAI,IAAK,KAAM,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,KAAM,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,KAAM,IAAK,GAAI,GAAI,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAA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","file":"0cd190e5-b5fffb28cb7d6e41a7cb.js","sourcesContent":["// Reserved word lists for various dialects of the language\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n}; // And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\nvar keywordRelationalOperator = /^in(stanceof)?$/; // ## Character categories\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7B9\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\";\nvar nonASCIIidentifierChars = \"\\u200C\\u200D\\xB7\\u0300-\\u036F\\u0387\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u0669\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u06F0-\\u06F9\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07C0-\\u07C9\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09E6-\\u09EF\\u09FE\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AE6-\\u0AEF\\u0AFA-\\u0AFF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B66-\\u0B6F\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C04\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0CE6-\\u0CEF\\u0D00-\\u0D03\\u0D3B\\u0D3C\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D66-\\u0D6F\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0E50-\\u0E59\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1040-\\u1049\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F-\\u109D\\u135D-\\u135F\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u194F\\u19D0-\\u19DA\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AB0-\\u1ABD\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BB0-\\u1BB9\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1C40-\\u1C49\\u1C50-\\u1C59\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF7-\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u203F\\u2040\\u2054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA620-\\uA629\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F1\\uA8FF-\\uA909\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9D0-\\uA9D9\\uA9E5\\uA9F0-\\uA9F9\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA50-\\uAA59\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F\";\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null; // These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n// eslint-disable-next-line comma-spacing\n\nvar astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 190, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 26, 230, 43, 117, 63, 32, 0, 257, 0, 11, 39, 8, 0, 22, 0, 12, 39, 3, 3, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 68, 12, 0, 67, 12, 65, 1, 31, 6129, 15, 754, 9486, 286, 82, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541]; // eslint-disable-next-line comma-spacing\n\nvar astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 280, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239]; // This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\n\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n\n    if (pos > code) {\n      return false;\n    }\n\n    pos += set[i + 1];\n\n    if (pos >= code) {\n      return true;\n    }\n  }\n} // Test whether a given character code starts an identifier.\n\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) {\n    return code === 36;\n  }\n\n  if (code < 91) {\n    return true;\n  }\n\n  if (code < 97) {\n    return code === 95;\n  }\n\n  if (code < 123) {\n    return true;\n  }\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  if (astral === false) {\n    return false;\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n} // Test whether a given character is part of an identifier.\n\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) {\n    return code === 36;\n  }\n\n  if (code < 58) {\n    return true;\n  }\n\n  if (code < 65) {\n    return false;\n  }\n\n  if (code < 91) {\n    return true;\n  }\n\n  if (code < 97) {\n    return code === 95;\n  }\n\n  if (code < 123) {\n    return true;\n  }\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  if (astral === false) {\n    return false;\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n} // ## Token types\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\n\nvar TokenType = function TokenType(label, conf) {\n  if (conf === void 0) conf = {};\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {\n    beforeExpr: true,\n    binop: prec\n  });\n}\n\nvar beforeExpr = {\n  beforeExpr: true\n};\nvar startsExpr = {\n  startsExpr: true\n}; // Map keyword names to token types.\n\nvar keywords$1 = {}; // Succinct definitions of keyword token types\n\nfunction kw(name, options) {\n  if (options === void 0) options = {};\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options);\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n  eq: new TokenType(\"=\", {\n    beforeExpr: true,\n    isAssign: true\n  }),\n  assign: new TokenType(\"_=\", {\n    beforeExpr: true,\n    isAssign: true\n  }),\n  incDec: new TokenType(\"++/--\", {\n    prefix: true,\n    postfix: true,\n    startsExpr: true\n  }),\n  prefix: new TokenType(\"!/~\", {\n    beforeExpr: true,\n    prefix: true,\n    startsExpr: true\n  }),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {\n    beforeExpr: true,\n    binop: 9,\n    prefix: true,\n    startsExpr: true\n  }),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {\n    beforeExpr: true\n  }),\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {\n    isLoop: true,\n    beforeExpr: true\n  }),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {\n    isLoop: true\n  }),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {\n    isLoop: true\n  }),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {\n    beforeExpr: true,\n    binop: 7\n  }),\n  _instanceof: kw(\"instanceof\", {\n    beforeExpr: true,\n    binop: 7\n  }),\n  _typeof: kw(\"typeof\", {\n    beforeExpr: true,\n    prefix: true,\n    startsExpr: true\n  }),\n  _void: kw(\"void\", {\n    beforeExpr: true,\n    prefix: true,\n    startsExpr: true\n  }),\n  _delete: kw(\"delete\", {\n    beforeExpr: true,\n    prefix: true,\n    startsExpr: true\n  })\n}; // Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code, ecma2019String) {\n  return code === 10 || code === 13 || !ecma2019String && (code === 0x2028 || code === 0x2029);\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString; // Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName);\n}\n\nvar isArray = Array.isArray || function (obj) {\n  return toString.call(obj) === \"[object Array]\";\n}; // These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset(n) {\n  return new Position(this.line, this.column + n);\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n\n  if (p.sourceFile !== null) {\n    this.source = p.sourceFile;\n  }\n}; // The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur);\n    }\n  }\n} // A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n}; // Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions) {\n    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];\n  }\n\n  if (options.ecmaVersion >= 2015) {\n    options.ecmaVersion -= 2009;\n  }\n\n  if (options.allowReserved == null) {\n    options.allowReserved = options.ecmaVersion < 5;\n  }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n\n    options.onToken = function (token) {\n      return tokens.push(token);\n    };\n  }\n\n  if (isArray(options.onComment)) {\n    options.onComment = pushComment(options, options.onComment);\n  }\n\n  return options;\n}\n\nfunction pushComment(options, array) {\n  return function (block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n\n    if (options.locations) {\n      comment.loc = new SourceLocation(this, startLoc, endLoc);\n    }\n\n    if (options.ranges) {\n      comment.range = [start, end];\n    }\n\n    array.push(comment);\n  };\n} // Registered plugins\n\n\nvar plugins = {};\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\");\n}\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n  var reserved = \"\";\n\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--) {\n      if (reserved = reservedWords[v]) {\n        break;\n      }\n    }\n\n    if (options.sourceType === \"module\") {\n      reserved += \" await\";\n    }\n  }\n\n  this.reservedWords = keywordRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = keywordRegexp(reservedStrict);\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input); // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n\n  this.containsEsc = false; // Load plugins\n\n  this.loadPlugins(options.plugins); // Set up token state\n  // The current position of the tokenizer in the input.\n\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  } // Properties of the current token:\n  // Its type\n\n\n  this.type = types.eof; // For tokens that include more information than their type, the value\n\n  this.value = null; // Its start and end offset\n\n  this.start = this.end = this.pos; // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n\n  this.startLoc = this.endLoc = this.curPosition(); // Position information for the previous token\n\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos; // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n\n  this.context = this.initialContext();\n  this.exprAllowed = true; // Figure out if it's a module code.\n\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos); // Used to signify the start of a potential arrow function\n\n  this.potentialArrowAt = -1; // Flags to track whether we are in a function, a generator, an async function.\n\n  this.inFunction = this.inGenerator = this.inAsync = false; // Positions to delayed-check that yield/await does not exist in default parameters.\n\n  this.yieldPos = this.awaitPos = 0; // Labels in scope.\n\n  this.labels = []; // If enabled, skip leading hashbang line.\n\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\") {\n    this.skipLineComment(2);\n  } // Scope tracking for duplicate variable names (see scope.js)\n\n\n  this.scopeStack = [];\n  this.enterFunctionScope(); // For RegExp validation\n\n  this.regexpState = null;\n}; // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\n\n\nParser.prototype.isKeyword = function isKeyword(word) {\n  return this.keywords.test(word);\n};\n\nParser.prototype.isReservedWord = function isReservedWord(word) {\n  return this.reservedWords.test(word);\n};\n\nParser.prototype.extend = function extend(name, f) {\n  this[name] = f(this[name]);\n};\n\nParser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {\n  var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name];\n\n    if (!plugin) {\n      throw new Error(\"Plugin '\" + name + \"' not found\");\n    }\n\n    plugin(this$1, pluginConfigs[name]);\n  }\n};\n\nParser.prototype.parse = function parse() {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node);\n};\n\nvar pp = Parser.prototype; // ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\"|;)/;\n\npp.strictDirective = function (start) {\n  var this$1 = this;\n\n  for (;;) {\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this$1.input)[0].length;\n    var match = literal.exec(this$1.input.slice(start));\n\n    if (!match) {\n      return false;\n    }\n\n    if ((match[1] || match[2]) === \"use strict\") {\n      return true;\n    }\n\n    start += match[0].length;\n  }\n}; // Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\n\npp.eat = function (type) {\n  if (this.type === type) {\n    this.next();\n    return true;\n  } else {\n    return false;\n  }\n}; // Tests whether parsed token is a contextual keyword.\n\n\npp.isContextual = function (name) {\n  return this.type === types.name && this.value === name && !this.containsEsc;\n}; // Consumes contextual keyword if possible.\n\n\npp.eatContextual = function (name) {\n  if (!this.isContextual(name)) {\n    return false;\n  }\n\n  this.next();\n  return true;\n}; // Asserts that following token is given contextual keyword.\n\n\npp.expectContextual = function (name) {\n  if (!this.eatContextual(name)) {\n    this.unexpected();\n  }\n}; // Test whether a semicolon can be inserted at the current position.\n\n\npp.canInsertSemicolon = function () {\n  return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n};\n\npp.insertSemicolon = function () {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon) {\n      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n    }\n\n    return true;\n  }\n}; // Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\n\npp.semicolon = function () {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) {\n    this.unexpected();\n  }\n};\n\npp.afterTrailingComma = function (tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma) {\n      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n    }\n\n    if (!notNext) {\n      this.next();\n    }\n\n    return true;\n  }\n}; // Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\n\npp.expect = function (type) {\n  this.eat(type) || this.unexpected();\n}; // Raise an unexpected token error.\n\n\npp.unexpected = function (pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;\n}\n\npp.checkPatternErrors = function (refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) {\n    return;\n  }\n\n  if (refDestructuringErrors.trailingComma > -1) {\n    this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\");\n  }\n\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n\n  if (parens > -1) {\n    this.raiseRecoverable(parens, \"Parenthesized pattern\");\n  }\n};\n\npp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) {\n    return false;\n  }\n\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n\n  if (!andThrow) {\n    return shorthandAssign >= 0 || doubleProto >= 0;\n  }\n\n  if (shorthandAssign >= 0) {\n    this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\");\n  }\n\n  if (doubleProto >= 0) {\n    this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\");\n  }\n};\n\npp.checkYieldAwaitInDefaultParams = function () {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {\n    this.raise(this.yieldPos, \"Yield expression cannot be a default value\");\n  }\n\n  if (this.awaitPos) {\n    this.raise(this.awaitPos, \"Await expression cannot be a default value\");\n  }\n};\n\npp.isSimpleAssignTarget = function (expr) {\n  if (expr.type === \"ParenthesizedExpression\") {\n    return this.isSimpleAssignTarget(expr.expression);\n  }\n\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\";\n};\n\nvar pp$1 = Parser.prototype; // ### Statement parsing\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function (node) {\n  var this$1 = this;\n  var exports = {};\n\n  if (!node.body) {\n    node.body = [];\n  }\n\n  while (this.type !== types.eof) {\n    var stmt = this$1.parseStatement(true, true, exports);\n    node.body.push(stmt);\n  }\n\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType;\n  }\n\n  return this.finishNode(node, \"Program\");\n};\n\nvar loopLabel = {\n  kind: \"loop\"\n};\nvar switchLabel = {\n  kind: \"switch\"\n};\n\npp$1.isLet = function () {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) {\n    return false;\n  }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length,\n      nextCh = this.input.charCodeAt(next);\n\n  if (nextCh === 91 || nextCh === 123) {\n    return true;\n  } // '{' and '['\n\n\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) {\n      ++pos;\n    }\n\n    var ident = this.input.slice(next, pos);\n\n    if (!keywordRelationalOperator.test(ident)) {\n      return true;\n    }\n  }\n\n  return false;\n}; // check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\n\n\npp$1.isAsyncFunction = function () {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\")) {\n    return false;\n  }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === \"function\" && (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));\n}; // Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\n\npp$1.parseStatement = function (declaration, topLevel, exports) {\n  var starttype = this.type,\n      node = this.startNode(),\n      kind;\n\n  if (this.isLet()) {\n    starttype = types._var;\n    kind = \"let\";\n  } // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n\n  switch (starttype) {\n    case types._break:\n    case types._continue:\n      return this.parseBreakContinueStatement(node, starttype.keyword);\n\n    case types._debugger:\n      return this.parseDebuggerStatement(node);\n\n    case types._do:\n      return this.parseDoStatement(node);\n\n    case types._for:\n      return this.parseForStatement(node);\n\n    case types._function:\n      if (!declaration && this.options.ecmaVersion >= 6) {\n        this.unexpected();\n      }\n\n      return this.parseFunctionStatement(node, false);\n\n    case types._class:\n      if (!declaration) {\n        this.unexpected();\n      }\n\n      return this.parseClass(node, true);\n\n    case types._if:\n      return this.parseIfStatement(node);\n\n    case types._return:\n      return this.parseReturnStatement(node);\n\n    case types._switch:\n      return this.parseSwitchStatement(node);\n\n    case types._throw:\n      return this.parseThrowStatement(node);\n\n    case types._try:\n      return this.parseTryStatement(node);\n\n    case types._const:\n    case types._var:\n      kind = kind || this.value;\n\n      if (!declaration && kind !== \"var\") {\n        this.unexpected();\n      }\n\n      return this.parseVarStatement(node, kind);\n\n    case types._while:\n      return this.parseWhileStatement(node);\n\n    case types._with:\n      return this.parseWithStatement(node);\n\n    case types.braceL:\n      return this.parseBlock();\n\n    case types.semi:\n      return this.parseEmptyStatement(node);\n\n    case types._export:\n    case types._import:\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel) {\n          this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n        }\n\n        if (!this.inModule) {\n          this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n        }\n      }\n\n      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n\n    default:\n      if (this.isAsyncFunction()) {\n        if (!declaration) {\n          this.unexpected();\n        }\n\n        this.next();\n        return this.parseFunctionStatement(node, true);\n      }\n\n      var maybeName = this.value,\n          expr = this.parseExpression();\n\n      if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon)) {\n        return this.parseLabeledStatement(node, maybeName, expr);\n      } else {\n        return this.parseExpressionStatement(node, expr);\n      }\n\n  }\n};\n\npp$1.parseBreakContinueStatement = function (node, keyword) {\n  var this$1 = this;\n  var isBreak = keyword === \"break\";\n  this.next();\n\n  if (this.eat(types.semi) || this.insertSemicolon()) {\n    node.label = null;\n  } else if (this.type !== types.name) {\n    this.unexpected();\n  } else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  } // Verify that there is an actual destination to break or\n  // continue to.\n\n\n  var i = 0;\n\n  for (; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i];\n\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) {\n        break;\n      }\n\n      if (node.label && isBreak) {\n        break;\n      }\n    }\n  }\n\n  if (i === this.labels.length) {\n    this.raise(node.start, \"Unsyntactic \" + keyword);\n  }\n\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n};\n\npp$1.parseDebuggerStatement = function (node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\");\n};\n\npp$1.parseDoStatement = function (node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n\n  if (this.options.ecmaVersion >= 6) {\n    this.eat(types.semi);\n  } else {\n    this.semicolon();\n  }\n\n  return this.finishNode(node, \"DoWhileStatement\");\n}; // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\n\npp$1.parseForStatement = function (node) {\n  this.next();\n  var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual(\"await\") ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterLexicalScope();\n  this.expect(types.parenL);\n\n  if (this.type === types.semi) {\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n\n    return this.parseFor(node, null);\n  }\n\n  var isLet = this.isLet();\n\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(),\n        kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n\n    if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && init$1.declarations.length === 1 && !(kind !== \"var\" && init$1.declarations[0].init)) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) {\n            this.unexpected(awaitAt);\n          }\n        } else {\n          node.await = awaitAt > -1;\n        }\n      }\n\n      return this.parseForIn(node, init$1);\n    }\n\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n\n    return this.parseFor(node, init$1);\n  }\n\n  var refDestructuringErrors = new DestructuringErrors();\n  var init = this.parseExpression(true, refDestructuringErrors);\n\n  if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types._in) {\n        if (awaitAt > -1) {\n          this.unexpected(awaitAt);\n        }\n      } else {\n        node.await = awaitAt > -1;\n      }\n    }\n\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLVal(init);\n    return this.parseForIn(node, init);\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n\n  if (awaitAt > -1) {\n    this.unexpected(awaitAt);\n  }\n\n  return this.parseFor(node, init);\n};\n\npp$1.parseFunctionStatement = function (node, isAsync) {\n  this.next();\n  return this.parseFunction(node, true, false, isAsync);\n};\n\npp$1.parseIfStatement = function (node) {\n  this.next();\n  node.test = this.parseParenExpression(); // allow function declarations in branches, but only in non-strict mode\n\n  node.consequent = this.parseStatement(!this.strict && this.type === types._function);\n  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;\n  return this.finishNode(node, \"IfStatement\");\n};\n\npp$1.parseReturnStatement = function (node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {\n    this.raise(this.start, \"'return' outside of function\");\n  }\n\n  this.next(); // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) {\n    node.argument = null;\n  } else {\n    node.argument = this.parseExpression();\n    this.semicolon();\n  }\n\n  return this.finishNode(node, \"ReturnStatement\");\n};\n\npp$1.parseSwitchStatement = function (node) {\n  var this$1 = this;\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterLexicalScope(); // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n\n  for (var sawDefault = false; this.type !== types.braceR;) {\n    if (this$1.type === types._case || this$1.type === types._default) {\n      var isCase = this$1.type === types._case;\n\n      if (cur) {\n        this$1.finishNode(cur, \"SwitchCase\");\n      }\n\n      node.cases.push(cur = this$1.startNode());\n      cur.consequent = [];\n      this$1.next();\n\n      if (isCase) {\n        cur.test = this$1.parseExpression();\n      } else {\n        if (sawDefault) {\n          this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\");\n        }\n\n        sawDefault = true;\n        cur.test = null;\n      }\n\n      this$1.expect(types.colon);\n    } else {\n      if (!cur) {\n        this$1.unexpected();\n      }\n\n      cur.consequent.push(this$1.parseStatement(true));\n    }\n  }\n\n  this.exitLexicalScope();\n\n  if (cur) {\n    this.finishNode(cur, \"SwitchCase\");\n  }\n\n  this.next(); // Closing brace\n\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\");\n};\n\npp$1.parseThrowStatement = function (node) {\n  this.next();\n\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {\n    this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n  }\n\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\");\n}; // Reused empty array added for node fields that are always empty.\n\n\nvar empty = [];\n\npp$1.parseTryStatement = function (node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n\n    if (this.eat(types.parenL)) {\n      clause.param = this.parseBindingAtom();\n      this.enterLexicalScope();\n      this.checkLVal(clause.param, \"let\");\n      this.expect(types.parenR);\n    } else {\n      if (this.options.ecmaVersion < 10) {\n        this.unexpected();\n      }\n\n      clause.param = null;\n      this.enterLexicalScope();\n    }\n\n    clause.body = this.parseBlock(false);\n    this.exitLexicalScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n\n  if (!node.handler && !node.finalizer) {\n    this.raise(node.start, \"Missing catch or finally clause\");\n  }\n\n  return this.finishNode(node, \"TryStatement\");\n};\n\npp$1.parseVarStatement = function (node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\");\n};\n\npp$1.parseWhileStatement = function (node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\");\n};\n\npp$1.parseWithStatement = function (node) {\n  if (this.strict) {\n    this.raise(this.start, \"'with' in strict mode\");\n  }\n\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(false);\n  return this.finishNode(node, \"WithStatement\");\n};\n\npp$1.parseEmptyStatement = function (node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\");\n};\n\npp$1.parseLabeledStatement = function (node, maybeName, expr) {\n  var this$1 = this;\n\n  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1) {\n    var label = list[i$1];\n\n    if (label.name === maybeName) {\n      this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n    }\n  }\n\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this$1.labels[i];\n\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this$1.start;\n      label$1.kind = kind;\n    } else {\n      break;\n    }\n  }\n\n  this.labels.push({\n    name: maybeName,\n    kind: kind,\n    statementStart: this.start\n  });\n  node.body = this.parseStatement(true);\n\n  if (node.body.type === \"ClassDeclaration\" || node.body.type === \"VariableDeclaration\" && node.body.kind !== \"var\" || node.body.type === \"FunctionDeclaration\" && (this.strict || node.body.generator || node.body.async)) {\n    this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\");\n  }\n\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\");\n};\n\npp$1.parseExpressionStatement = function (node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\");\n}; // Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\n\npp$1.parseBlock = function (createNewLexicalScope) {\n  var this$1 = this;\n  if (createNewLexicalScope === void 0) createNewLexicalScope = true;\n  var node = this.startNode();\n  node.body = [];\n  this.expect(types.braceL);\n\n  if (createNewLexicalScope) {\n    this.enterLexicalScope();\n  }\n\n  while (!this.eat(types.braceR)) {\n    var stmt = this$1.parseStatement(true);\n    node.body.push(stmt);\n  }\n\n  if (createNewLexicalScope) {\n    this.exitLexicalScope();\n  }\n\n  return this.finishNode(node, \"BlockStatement\");\n}; // Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\n\npp$1.parseFor = function (node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\");\n}; // Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\n\npp$1.parseForIn = function (node, init) {\n  var type = this.type === types._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n\n  if (type === \"ForInStatement\") {\n    if (init.type === \"AssignmentPattern\" || init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (this.strict || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(init.start, \"Invalid assignment in for-in loop head\");\n    }\n  }\n\n  node.left = init;\n  node.right = type === \"ForInStatement\" ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, type);\n}; // Parse a list of variable declarations.\n\n\npp$1.parseVar = function (node, isFor, kind) {\n  var this$1 = this;\n  node.declarations = [];\n  node.kind = kind;\n\n  for (;;) {\n    var decl = this$1.startNode();\n    this$1.parseVarId(decl, kind);\n\n    if (this$1.eat(types.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this$1.type === types._in || this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\"))) {\n      this$1.unexpected();\n    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this$1.type === types._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n\n    if (!this$1.eat(types.comma)) {\n      break;\n    }\n  }\n\n  return node;\n};\n\npp$1.parseVarId = function (decl, kind) {\n  decl.id = this.parseBindingAtom(kind);\n  this.checkLVal(decl.id, kind, false);\n}; // Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\n\npp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n    node.generator = this.eat(types.star);\n  }\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n\n  if (isStatement) {\n    node.id = isStatement === \"nullableID\" && this.type !== types.name ? null : this.parseIdent();\n\n    if (node.id) {\n      this.checkLVal(node.id, this.inModule && !this.inFunction ? \"let\" : \"var\");\n    }\n  }\n\n  var oldInGen = this.inGenerator,\n      oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos,\n      oldAwaitPos = this.awaitPos,\n      oldInFunc = this.inFunction;\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  if (!isStatement) {\n    node.id = this.type === types.name ? this.parseIdent() : null;\n  }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody);\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n};\n\npp$1.parseFunctionParams = function (node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n}; // Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\n\npp$1.parseClass = function (node, isStatement) {\n  var this$1 = this;\n  this.next();\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n\n  while (!this.eat(types.braceR)) {\n    var member = this$1.parseClassMember(classBody);\n\n    if (member && member.type === \"MethodDefinition\" && member.kind === \"constructor\") {\n      if (hadConstructor) {\n        this$1.raise(member.start, \"Duplicate constructor in the same class\");\n      }\n\n      hadConstructor = true;\n    }\n  }\n\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n};\n\npp$1.parseClassMember = function (classBody) {\n  var this$1 = this;\n\n  if (this.eat(types.semi)) {\n    return null;\n  }\n\n  var method = this.startNode();\n\n  var tryContextual = function tryContextual(k, noLineBreak) {\n    if (noLineBreak === void 0) noLineBreak = false;\n    var start = this$1.start,\n        startLoc = this$1.startLoc;\n\n    if (!this$1.eatContextual(k)) {\n      return false;\n    }\n\n    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) {\n      return true;\n    }\n\n    if (method.key) {\n      this$1.unexpected();\n    }\n\n    method.computed = false;\n    method.key = this$1.startNodeAt(start, startLoc);\n    method.key.name = k;\n    this$1.finishNode(method.key, \"Identifier\");\n    return false;\n  };\n\n  method.kind = \"method\";\n  method.static = tryContextual(\"static\");\n  var isGenerator = this.eat(types.star);\n  var isAsync = false;\n\n  if (!isGenerator) {\n    if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    } else if (tryContextual(\"get\")) {\n      method.kind = \"get\";\n    } else if (tryContextual(\"set\")) {\n      method.kind = \"set\";\n    }\n  }\n\n  if (!method.key) {\n    this.parsePropertyName(method);\n  }\n\n  var key = method.key;\n\n  if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" || key.type === \"Literal\" && key.value === \"constructor\")) {\n    if (method.kind !== \"method\") {\n      this.raise(key.start, \"Constructor can't have get/set modifier\");\n    }\n\n    if (isGenerator) {\n      this.raise(key.start, \"Constructor can't be a generator\");\n    }\n\n    if (isAsync) {\n      this.raise(key.start, \"Constructor can't be an async method\");\n    }\n\n    method.kind = \"constructor\";\n  } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n\n  this.parseClassMethod(classBody, method, isGenerator, isAsync);\n\n  if (method.kind === \"get\" && method.value.params.length !== 0) {\n    this.raiseRecoverable(method.value.start, \"getter should have no params\");\n  }\n\n  if (method.kind === \"set\" && method.value.params.length !== 1) {\n    this.raiseRecoverable(method.value.start, \"setter should have exactly one param\");\n  }\n\n  if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\") {\n    this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\");\n  }\n\n  return method;\n};\n\npp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync);\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n};\n\npp$1.parseClassId = function (node, isStatement) {\n  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;\n};\n\npp$1.parseClassSuper = function (node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n}; // Parses module export declaration.\n\n\npp$1.parseExport = function (node, exports) {\n  var this$1 = this;\n  this.next(); // export * from '...'\n\n  if (this.eat(types.star)) {\n    this.expectContextual(\"from\");\n\n    if (this.type !== types.string) {\n      this.unexpected();\n    }\n\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\");\n  }\n\n  if (this.eat(types._default)) {\n    // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n\n      if (isAsync) {\n        this.next();\n      }\n\n      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ExportDefaultDeclaration\");\n  } // export var|const|let|function|class ...\n\n\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true);\n\n    if (node.declaration.type === \"VariableDeclaration\") {\n      this.checkVariableExport(exports, node.declaration.declarations);\n    } else {\n      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n    }\n\n    node.specifiers = [];\n    node.source = null;\n  } else {\n    // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types.string) {\n        this.unexpected();\n      }\n\n      node.source = this.parseExprAtom();\n    } else {\n      // check for keywords used as local names\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        var spec = list[i];\n        this$1.checkUnreserved(spec.local);\n      }\n\n      node.source = null;\n    }\n\n    this.semicolon();\n  }\n\n  return this.finishNode(node, \"ExportNamedDeclaration\");\n};\n\npp$1.checkExport = function (exports, name, pos) {\n  if (!exports) {\n    return;\n  }\n\n  if (has(exports, name)) {\n    this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\");\n  }\n\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function (exports, pat) {\n  var this$1 = this;\n  var type = pat.type;\n\n  if (type === \"Identifier\") {\n    this.checkExport(exports, pat.name, pat.start);\n  } else if (type === \"ObjectPattern\") {\n    for (var i = 0, list = pat.properties; i < list.length; i += 1) {\n      var prop = list[i];\n      this$1.checkPatternExport(exports, prop);\n    }\n  } else if (type === \"ArrayPattern\") {\n    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n      if (elt) {\n        this$1.checkPatternExport(exports, elt);\n      }\n    }\n  } else if (type === \"Property\") {\n    this.checkPatternExport(exports, pat.value);\n  } else if (type === \"AssignmentPattern\") {\n    this.checkPatternExport(exports, pat.left);\n  } else if (type === \"RestElement\") {\n    this.checkPatternExport(exports, pat.argument);\n  } else if (type === \"ParenthesizedExpression\") {\n    this.checkPatternExport(exports, pat.expression);\n  }\n};\n\npp$1.checkVariableExport = function (exports, decls) {\n  var this$1 = this;\n\n  if (!exports) {\n    return;\n  }\n\n  for (var i = 0, list = decls; i < list.length; i += 1) {\n    var decl = list[i];\n    this$1.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function () {\n  return this.type.keyword === \"var\" || this.type.keyword === \"const\" || this.type.keyword === \"class\" || this.type.keyword === \"function\" || this.isLet() || this.isAsyncFunction();\n}; // Parses a comma-separated list of module exports.\n\n\npp$1.parseExportSpecifiers = function (exports) {\n  var this$1 = this;\n  var nodes = [],\n      first = true; // export { x, y as z } [from '...']\n\n  this.expect(types.braceL);\n\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n\n      if (this$1.afterTrailingComma(types.braceR)) {\n        break;\n      }\n    } else {\n      first = false;\n    }\n\n    var node = this$1.startNode();\n    node.local = this$1.parseIdent(true);\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local;\n    this$1.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"));\n  }\n\n  return nodes;\n}; // Parses import declaration.\n\n\npp$1.parseImport = function (node) {\n  this.next(); // import '...'\n\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\");\n}; // Parses a comma-separated list of module imports.\n\n\npp$1.parseImportSpecifiers = function () {\n  var this$1 = this;\n  var nodes = [],\n      first = true;\n\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, \"let\");\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n\n    if (!this.eat(types.comma)) {\n      return nodes;\n    }\n  }\n\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, \"let\");\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes;\n  }\n\n  this.expect(types.braceL);\n\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n\n      if (this$1.afterTrailingComma(types.braceR)) {\n        break;\n      }\n    } else {\n      first = false;\n    }\n\n    var node$2 = this$1.startNode();\n    node$2.imported = this$1.parseIdent(true);\n\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent();\n    } else {\n      this$1.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n\n    this$1.checkLVal(node$2.local, \"let\");\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n  }\n\n  return nodes;\n}; // Set `ExpressionStatement#directive` property for directive prologues.\n\n\npp$1.adaptDirectivePrologue = function (statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\n\npp$1.isDirectiveCandidate = function (statement) {\n  return statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\" && typeof statement.expression.value === \"string\" && ( // Reject parenthesized strings.\n  this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\");\n};\n\nvar pp$2 = Parser.prototype; // Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function (node, isBinding, refDestructuringErrors) {\n  var this$1 = this;\n\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n      case \"Identifier\":\n        if (this.inAsync && node.name === \"await\") {\n          this.raise(node.start, \"Can not use 'await' as identifier inside an async function\");\n        }\n\n        break;\n\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"RestElement\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n\n        if (refDestructuringErrors) {\n          this.checkPatternErrors(refDestructuringErrors, true);\n        }\n\n        for (var i = 0, list = node.properties; i < list.length; i += 1) {\n          var prop = list[i];\n          this$1.toAssignable(prop, isBinding); // Early error:\n          //   AssignmentRestProperty[Yield, Await] :\n          //     `...` DestructuringAssignmentTarget[Yield, Await]\n          //\n          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n\n          if (prop.type === \"RestElement\" && (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")) {\n            this$1.raise(prop.argument.start, \"Unexpected token\");\n          }\n        }\n\n        break;\n\n      case \"Property\":\n        // AssignmentProperty has type === \"Property\"\n        if (node.kind !== \"init\") {\n          this.raise(node.key.start, \"Object pattern can't contain getter or setter\");\n        }\n\n        this.toAssignable(node.value, isBinding);\n        break;\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n\n        if (refDestructuringErrors) {\n          this.checkPatternErrors(refDestructuringErrors, true);\n        }\n\n        this.toAssignableList(node.elements, isBinding);\n        break;\n\n      case \"SpreadElement\":\n        node.type = \"RestElement\";\n        this.toAssignable(node.argument, isBinding);\n\n        if (node.argument.type === \"AssignmentPattern\") {\n          this.raise(node.argument.start, \"Rest elements cannot have a default value\");\n        }\n\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isBinding);\n      // falls through to AssignmentPattern\n\n      case \"AssignmentPattern\":\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isBinding);\n        break;\n\n      case \"MemberExpression\":\n        if (!isBinding) {\n          break;\n        }\n\n      default:\n        this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) {\n    this.checkPatternErrors(refDestructuringErrors, true);\n  }\n\n  return node;\n}; // Convert list of expression atoms to binding list.\n\n\npp$2.toAssignableList = function (exprList, isBinding) {\n  var this$1 = this;\n  var end = exprList.length;\n\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n\n    if (elt) {\n      this$1.toAssignable(elt, isBinding);\n    }\n  }\n\n  if (end) {\n    var last = exprList[end - 1];\n\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\") {\n      this.unexpected(last.argument.start);\n    }\n  }\n\n  return exprList;\n}; // Parses spread element.\n\n\npp$2.parseSpread = function (refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\");\n};\n\npp$2.parseRestBinding = function () {\n  var node = this.startNode();\n  this.next(); // RestElement inside of a function parameter must be an identifier\n\n  if (this.options.ecmaVersion === 6 && this.type !== types.name) {\n    this.unexpected();\n  }\n\n  node.argument = this.parseBindingAtom();\n  return this.finishNode(node, \"RestElement\");\n}; // Parses lvalue (assignable) atom.\n\n\npp$2.parseBindingAtom = function () {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n      case types.bracketL:\n        var node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(types.bracketR, true, true);\n        return this.finishNode(node, \"ArrayPattern\");\n\n      case types.braceL:\n        return this.parseObj(true);\n    }\n  }\n\n  return this.parseIdent();\n};\n\npp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma) {\n  var this$1 = this;\n  var elts = [],\n      first = true;\n\n  while (!this.eat(close)) {\n    if (first) {\n      first = false;\n    } else {\n      this$1.expect(types.comma);\n    }\n\n    if (allowEmpty && this$1.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break;\n    } else if (this$1.type === types.ellipsis) {\n      var rest = this$1.parseRestBinding();\n      this$1.parseBindingListItem(rest);\n      elts.push(rest);\n\n      if (this$1.type === types.comma) {\n        this$1.raise(this$1.start, \"Comma is not permitted after the rest element\");\n      }\n\n      this$1.expect(close);\n      break;\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);\n      this$1.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n\n  return elts;\n};\n\npp$2.parseBindingListItem = function (param) {\n  return param;\n}; // Parses assignment pattern around given atom if possible.\n\n\npp$2.parseMaybeDefault = function (startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {\n    return left;\n  }\n\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\");\n}; // Verify that a node is an lval — something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\n\npp$2.checkLVal = function (expr, bindingType, checkClashes) {\n  var this$1 = this;\n\n  switch (expr.type) {\n    case \"Identifier\":\n      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {\n        this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n      }\n\n      if (checkClashes) {\n        if (has(checkClashes, expr.name)) {\n          this.raiseRecoverable(expr.start, \"Argument name clash\");\n        }\n\n        checkClashes[expr.name] = true;\n      }\n\n      if (bindingType && bindingType !== \"none\") {\n        if (bindingType === \"var\" && !this.canDeclareVarName(expr.name) || bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)) {\n          this.raiseRecoverable(expr.start, \"Identifier '\" + expr.name + \"' has already been declared\");\n        }\n\n        if (bindingType === \"var\") {\n          this.declareVarName(expr.name);\n        } else {\n          this.declareLexicalName(expr.name);\n        }\n      }\n\n      break;\n\n    case \"MemberExpression\":\n      if (bindingType) {\n        this.raiseRecoverable(expr.start, \"Binding member expression\");\n      }\n\n      break;\n\n    case \"ObjectPattern\":\n      for (var i = 0, list = expr.properties; i < list.length; i += 1) {\n        var prop = list[i];\n        this$1.checkLVal(prop, bindingType, checkClashes);\n      }\n\n      break;\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      this.checkLVal(expr.value, bindingType, checkClashes);\n      break;\n\n    case \"ArrayPattern\":\n      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n        var elem = list$1[i$1];\n\n        if (elem) {\n          this$1.checkLVal(elem, bindingType, checkClashes);\n        }\n      }\n\n      break;\n\n    case \"AssignmentPattern\":\n      this.checkLVal(expr.left, bindingType, checkClashes);\n      break;\n\n    case \"RestElement\":\n      this.checkLVal(expr.argument, bindingType, checkClashes);\n      break;\n\n    case \"ParenthesizedExpression\":\n      this.checkLVal(expr.expression, bindingType, checkClashes);\n      break;\n\n    default:\n      this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n}; // A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n\nvar pp$3 = Parser.prototype; // Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function (prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\") {\n    return;\n  }\n\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {\n    return;\n  }\n\n  var key = prop.key;\n  var name;\n\n  switch (key.type) {\n    case \"Identifier\":\n      name = key.name;\n      break;\n\n    case \"Literal\":\n      name = String(key.value);\n      break;\n\n    default:\n      return;\n  }\n\n  var kind = prop.kind;\n\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) {\n          refDestructuringErrors.doubleProto = key.start;\n        } // Backwards-compat kludge. Can be removed in version 6.0\n        else {\n            this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n          }\n      }\n\n      propHash.proto = true;\n    }\n\n    return;\n  }\n\n  name = \"$\" + name;\n  var other = propHash[name];\n\n  if (other) {\n    var redefinition;\n\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n\n    if (redefinition) {\n      this.raiseRecoverable(key.start, \"Redefinition of property\");\n    }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n\n  other[kind] = true;\n}; // ### Expression parsing\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\n\npp$3.parseExpression = function (noIn, refDestructuringErrors) {\n  var this$1 = this;\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n\n    while (this.eat(types.comma)) {\n      node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors));\n    }\n\n    return this.finishNode(node, \"SequenceExpression\");\n  }\n\n  return expr;\n}; // Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\n\npp$3.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) {\n    return this.parseYield();\n  }\n\n  var ownDestructuringErrors = false,\n      oldParenAssign = -1,\n      oldTrailingComma = -1;\n\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors();\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start,\n      startLoc = this.startLoc;\n\n  if (this.type === types.parenL || this.type === types.name) {\n    this.potentialArrowAt = this.start;\n  }\n\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n\n  if (afterLeftParse) {\n    left = afterLeftParse.call(this, left, startPos, startLoc);\n  }\n\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n\n    if (!ownDestructuringErrors) {\n      DestructuringErrors.call(refDestructuringErrors);\n    }\n\n    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\");\n  } else {\n    if (ownDestructuringErrors) {\n      this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n  }\n\n  if (oldParenAssign > -1) {\n    refDestructuringErrors.parenthesizedAssign = oldParenAssign;\n  }\n\n  if (oldTrailingComma > -1) {\n    refDestructuringErrors.trailingComma = oldTrailingComma;\n  }\n\n  return left;\n}; // Parse a ternary conditional (`?:`) operator.\n\n\npp$3.parseMaybeConditional = function (noIn, refDestructuringErrors) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n\n  if (this.checkExpressionErrors(refDestructuringErrors)) {\n    return expr;\n  }\n\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n\n  return expr;\n}; // Start the precedence parser.\n\n\npp$3.parseExprOps = function (noIn, refDestructuringErrors) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n\n  if (this.checkExpressionErrors(refDestructuringErrors)) {\n    return expr;\n  }\n\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n}; // Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\n\npp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var op = this.value;\n      this.next();\n      var startPos = this.start,\n          startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n    }\n  }\n\n  return left;\n};\n\npp$3.buildBinary = function (startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\");\n}; // Parse unary operators, both prefix and postfix.\n\n\npp$3.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n  var startPos = this.start,\n      startLoc = this.startLoc,\n      expr;\n\n  if (this.isContextual(\"await\") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(),\n        update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n\n    if (update) {\n      this.checkLVal(node.argument);\n    } else if (this.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n      this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\");\n    } else {\n      sawUnary = true;\n    }\n\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n\n    if (this.checkExpressionErrors(refDestructuringErrors)) {\n      return expr;\n    }\n\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.operator = this$1.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this$1.checkLVal(expr);\n      this$1.next();\n      expr = this$1.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar)) {\n    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false);\n  } else {\n    return expr;\n  }\n}; // Parse call, dot, and `[]`-subscript expressions.\n\n\npp$3.parseExprSubscripts = function (refDestructuringErrors) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) {\n    return expr;\n  }\n\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) {\n      refDestructuringErrors.parenthesizedAssign = -1;\n    }\n\n    if (refDestructuringErrors.parenthesizedBind >= result.start) {\n      refDestructuringErrors.parenthesizedBind = -1;\n    }\n  }\n\n  return result;\n};\n\npp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n\n  for (var computed = void 0;;) {\n    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\n      node.computed = !!computed;\n\n      if (computed) {\n        this$1.expect(types.bracketR);\n      }\n\n      base = this$1.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this$1.eat(types.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors(),\n          oldYieldPos = this$1.yieldPos,\n          oldAwaitPos = this$1.awaitPos;\n      this$1.yieldPos = 0;\n      this$1.awaitPos = 0;\n      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false);\n        this$1.checkYieldAwaitInDefaultParams();\n        this$1.yieldPos = oldYieldPos;\n        this$1.awaitPos = oldAwaitPos;\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true);\n      }\n\n      this$1.checkExpressionErrors(refDestructuringErrors, true);\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      base = this$1.finishNode(node$1, \"CallExpression\");\n    } else if (this$1.type === types.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this$1.parseTemplate({\n        isTagged: true\n      });\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\n    } else {\n      return base;\n    }\n  }\n}; // Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\n\npp$3.parseExprAtom = function (refDestructuringErrors) {\n  var node,\n      canBeArrow = this.potentialArrowAt === this.start;\n\n  switch (this.type) {\n    case types._super:\n      if (!this.inFunction) {\n        this.raise(this.start, \"'super' outside of function or class\");\n      }\n\n      node = this.startNode();\n      this.next(); // The `super` keyword can appear at below:\n      // SuperProperty:\n      //     super [ Expression ]\n      //     super . IdentifierName\n      // SuperCall:\n      //     super Arguments\n\n      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {\n        this.unexpected();\n      }\n\n      return this.finishNode(node, \"Super\");\n\n    case types._this:\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"ThisExpression\");\n\n    case types.name:\n      var startPos = this.start,\n          startLoc = this.startLoc,\n          containsEsc = this.containsEsc;\n      var id = this.parseIdent(this.type !== types.name);\n\n      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function)) {\n        return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true);\n      }\n\n      if (canBeArrow && !this.canInsertSemicolon()) {\n        if (this.eat(types.arrow)) {\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);\n        }\n\n        if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n          id = this.parseIdent();\n\n          if (this.canInsertSemicolon() || !this.eat(types.arrow)) {\n            this.unexpected();\n          }\n\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);\n        }\n      }\n\n      return id;\n\n    case types.regexp:\n      var value = this.value;\n      node = this.parseLiteral(value.value);\n      node.regex = {\n        pattern: value.pattern,\n        flags: value.flags\n      };\n      return node;\n\n    case types.num:\n    case types.string:\n      return this.parseLiteral(this.value);\n\n    case types._null:\n    case types._true:\n    case types._false:\n      node = this.startNode();\n      node.value = this.type === types._null ? null : this.type === types._true;\n      node.raw = this.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\");\n\n    case types.parenL:\n      var start = this.start,\n          expr = this.parseParenAndDistinguishExpression(canBeArrow);\n\n      if (refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {\n          refDestructuringErrors.parenthesizedAssign = start;\n        }\n\n        if (refDestructuringErrors.parenthesizedBind < 0) {\n          refDestructuringErrors.parenthesizedBind = start;\n        }\n      }\n\n      return expr;\n\n    case types.bracketL:\n      node = this.startNode();\n      this.next();\n      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n      return this.finishNode(node, \"ArrayExpression\");\n\n    case types.braceL:\n      return this.parseObj(false, refDestructuringErrors);\n\n    case types._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, false);\n\n    case types._class:\n      return this.parseClass(this.startNode(), false);\n\n    case types._new:\n      return this.parseNew();\n\n    case types.backQuote:\n      return this.parseTemplate();\n\n    default:\n      this.unexpected();\n  }\n};\n\npp$3.parseLiteral = function (value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  this.next();\n  return this.finishNode(node, \"Literal\");\n};\n\npp$3.parseParenExpression = function () {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val;\n};\n\npp$3.parseParenAndDistinguishExpression = function (canBeArrow) {\n  var this$1 = this;\n  var startPos = this.start,\n      startLoc = this.startLoc,\n      val,\n      allowTrailingComma = this.options.ecmaVersion >= 8;\n\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n    var innerStartPos = this.start,\n        innerStartLoc = this.startLoc;\n    var exprList = [],\n        first = true,\n        lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors(),\n        oldYieldPos = this.yieldPos,\n        oldAwaitPos = this.awaitPos,\n        spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n\n    while (this.type !== types.parenR) {\n      first ? first = false : this$1.expect(types.comma);\n\n      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break;\n      } else if (this$1.type === types.ellipsis) {\n        spreadStart = this$1.start;\n        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));\n\n        if (this$1.type === types.comma) {\n          this$1.raise(this$1.start, \"Comma is not permitted after the rest element\");\n        }\n\n        break;\n      } else {\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));\n      }\n    }\n\n    var innerEndPos = this.start,\n        innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList);\n    }\n\n    if (!exprList.length || lastIsComma) {\n      this.unexpected(this.lastTokStart);\n    }\n\n    if (spreadStart) {\n      this.unexpected(spreadStart);\n    }\n\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\");\n  } else {\n    return val;\n  }\n};\n\npp$3.parseParenItem = function (item) {\n  return item;\n};\n\npp$3.parseParenArrowList = function (startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);\n}; // New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\n\nvar empty$1 = [];\n\npp$3.parseNew = function () {\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n\n    if (node.property.name !== \"target\" || containsEsc) {\n      this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\");\n    }\n\n    if (!this.inFunction) {\n      this.raiseRecoverable(node.start, \"new.target can only be used in functions\");\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n\n  if (this.eat(types.parenL)) {\n    node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);\n  } else {\n    node.arguments = empty$1;\n  }\n\n  return this.finishNode(node, \"NewExpression\");\n}; // Parse template expression.\n\n\npp$3.parseTemplateElement = function (ref) {\n  var isTagged = ref.isTagged;\n  var elem = this.startNode();\n\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\");\n};\n\npp$3.parseTemplate = function (ref) {\n  var this$1 = this;\n  if (ref === void 0) ref = {};\n  var isTagged = ref.isTagged;\n  if (isTagged === void 0) isTagged = false;\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({\n    isTagged: isTagged\n  });\n  node.quasis = [curElt];\n\n  while (!curElt.tail) {\n    if (this$1.type === types.eof) {\n      this$1.raise(this$1.pos, \"Unterminated template literal\");\n    }\n\n    this$1.expect(types.dollarBraceL);\n    node.expressions.push(this$1.parseExpression());\n    this$1.expect(types.braceR);\n    node.quasis.push(curElt = this$1.parseTemplateElement({\n      isTagged: isTagged\n    }));\n  }\n\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\");\n};\n\npp$3.isAsyncProp = function (prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n}; // Parse an object literal or binding pattern.\n\n\npp$3.parseObj = function (isPattern, refDestructuringErrors) {\n  var this$1 = this;\n  var node = this.startNode(),\n      first = true,\n      propHash = {};\n  node.properties = [];\n  this.next();\n\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n\n      if (this$1.afterTrailingComma(types.braceR)) {\n        break;\n      }\n    } else {\n      first = false;\n    }\n\n    var prop = this$1.parseProperty(isPattern, refDestructuringErrors);\n\n    if (!isPattern) {\n      this$1.checkPropClash(prop, propHash, refDestructuringErrors);\n    }\n\n    node.properties.push(prop);\n  }\n\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n};\n\npp$3.parseProperty = function (isPattern, refDestructuringErrors) {\n  var prop = this.startNode(),\n      isGenerator,\n      isAsync,\n      startPos,\n      startLoc;\n\n  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n\n      if (this.type === types.comma) {\n        this.raise(this.start, \"Comma is not permitted after the rest element\");\n      }\n\n      return this.finishNode(prop, \"RestElement\");\n    } // To disallow parenthesized identifier via `this.toAssignable()`.\n\n\n    if (this.type === types.parenL && refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0) {\n        refDestructuringErrors.parenthesizedAssign = this.start;\n      }\n\n      if (refDestructuringErrors.parenthesizedBind < 0) {\n        refDestructuringErrors.parenthesizedBind = this.start;\n      }\n    } // Parse argument.\n\n\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors); // To disallow trailing comma via `this.toAssignable()`.\n\n    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    } // Finish\n\n\n    return this.finishNode(prop, \"SpreadElement\");\n  }\n\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n\n    if (!isPattern) {\n      isGenerator = this.eat(types.star);\n    }\n  }\n\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    this.parsePropertyName(prop, refDestructuringErrors);\n  } else {\n    isAsync = false;\n  }\n\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\");\n};\n\npp$3.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types.colon) {\n    this.unexpected();\n  }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) {\n      this.unexpected();\n    }\n\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.type !== types.comma && this.type !== types.braceR) {\n    if (isGenerator || isAsync) {\n      this.unexpected();\n    }\n\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n\n      if (prop.kind === \"get\") {\n        this.raiseRecoverable(start, \"getter should have no params\");\n      } else {\n        this.raiseRecoverable(start, \"setter should have exactly one param\");\n      }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\n        this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\");\n      }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    this.checkUnreserved(prop.key);\n    prop.kind = \"init\";\n\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0) {\n        refDestructuringErrors.shorthandAssign = this.start;\n      }\n\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n\n    prop.shorthand = true;\n  } else {\n    this.unexpected();\n  }\n};\n\npp$3.parsePropertyName = function (prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key;\n    } else {\n      prop.computed = false;\n    }\n  }\n\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true);\n}; // Initialize empty function node.\n\n\npp$3.initFunction = function (node) {\n  node.id = null;\n\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = false;\n  }\n}; // Parse object or class method.\n\n\npp$3.parseMethod = function (isGenerator, isAsync) {\n  var node = this.startNode(),\n      oldInGen = this.inGenerator,\n      oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos,\n      oldAwaitPos = this.awaitPos,\n      oldInFunc = this.inFunction;\n  this.initFunction(node);\n\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = isGenerator;\n  }\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false);\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"FunctionExpression\");\n}; // Parse arrow function expression with given parameters.\n\n\npp$3.parseArrowExpression = function (node, params, isAsync) {\n  var oldInGen = this.inGenerator,\n      oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos,\n      oldAwaitPos = this.awaitPos,\n      oldInFunc = this.inFunction;\n  this.enterFunctionScope();\n  this.initFunction(node);\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n\n  this.inGenerator = false;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true);\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"ArrowFunctionExpression\");\n}; // Parse function body and check parameters.\n\n\npp$3.parseFunctionBody = function (node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict,\n      useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end); // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n\n      if (useStrict && nonSimple) {\n        this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n      }\n    } // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n\n\n    var oldLabels = this.labels;\n    this.labels = [];\n\n    if (useStrict) {\n      this.strict = true;\n    } // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n\n\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));\n    node.body = this.parseBlock(false);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n\n  this.exitFunctionScope();\n\n  if (this.strict && node.id) {\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    this.checkLVal(node.id, \"none\");\n  }\n\n  this.strict = oldStrict;\n};\n\npp$3.isSimpleParamList = function (params) {\n  for (var i = 0, list = params; i < list.length; i += 1) {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") {\n      return false;\n    }\n  }\n\n  return true;\n}; // Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\n\npp$3.checkParams = function (node, allowDuplicates) {\n  var this$1 = this;\n  var nameHash = {};\n\n  for (var i = 0, list = node.params; i < list.length; i += 1) {\n    var param = list[i];\n    this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\n  }\n}; // Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\n\npp$3.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n  var elts = [],\n      first = true;\n\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(types.comma);\n\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n        break;\n      }\n    } else {\n      first = false;\n    }\n\n    var elt = void 0;\n\n    if (allowEmpty && this$1.type === types.comma) {\n      elt = null;\n    } else if (this$1.type === types.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors);\n\n      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0) {\n        refDestructuringErrors.trailingComma = this$1.start;\n      }\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);\n    }\n\n    elts.push(elt);\n  }\n\n  return elts;\n};\n\npp$3.checkUnreserved = function (ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\") {\n    this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\");\n  }\n\n  if (this.inAsync && name === \"await\") {\n    this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\");\n  }\n\n  if (this.isKeyword(name)) {\n    this.raise(start, \"Unexpected keyword '\" + name + \"'\");\n  }\n\n  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf(\"\\\\\") !== -1) {\n    return;\n  }\n\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\") {\n      this.raiseRecoverable(start, \"Can not use keyword 'await' outside an async function\");\n    }\n\n    this.raiseRecoverable(start, \"The keyword '\" + name + \"' is reserved\");\n  }\n}; // Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\n\npp$3.parseIdent = function (liberal, isBinding) {\n  var node = this.startNode();\n\n  if (liberal && this.options.allowReserved === \"never\") {\n    liberal = false;\n  }\n\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword; // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n\n    if ((node.name === \"class\" || node.name === \"function\") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n  } else {\n    this.unexpected();\n  }\n\n  this.next();\n  this.finishNode(node, \"Identifier\");\n\n  if (!liberal) {\n    this.checkUnreserved(node);\n  }\n\n  return node;\n}; // Parses yield expression inside generator.\n\n\npp$3.parseYield = function () {\n  if (!this.yieldPos) {\n    this.yieldPos = this.start;\n  }\n\n  var node = this.startNode();\n  this.next();\n\n  if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign();\n  }\n\n  return this.finishNode(node, \"YieldExpression\");\n};\n\npp$3.parseAwait = function () {\n  if (!this.awaitPos) {\n    this.awaitPos = this.start;\n  }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true);\n  return this.finishNode(node, \"AwaitExpression\");\n};\n\nvar pp$4 = Parser.prototype; // This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function (pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos;\n  err.loc = loc;\n  err.raisedAt = this.pos;\n  throw err;\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function () {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  }\n};\n\nvar pp$5 = Parser.prototype; // Object.assign polyfill\n\nvar assign = Object.assign || function (target) {\n  var sources = [],\n      len = arguments.length - 1;\n\n  while (len-- > 0) {\n    sources[len] = arguments[len + 1];\n  }\n\n  for (var i = 0, list = sources; i < list.length; i += 1) {\n    var source = list[i];\n\n    for (var key in source) {\n      if (has(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n}; // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\n\npp$5.enterFunctionScope = function () {\n  // var: a hash of var-declared names in the current lexical scope\n  // lexical: a hash of lexically-declared names in the current lexical scope\n  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n  this.scopeStack.push({\n    var: {},\n    lexical: {},\n    childVar: {},\n    parentLexical: {}\n  });\n};\n\npp$5.exitFunctionScope = function () {\n  this.scopeStack.pop();\n};\n\npp$5.enterLexicalScope = function () {\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n  var childScope = {\n    var: {},\n    lexical: {},\n    childVar: {},\n    parentLexical: {}\n  };\n  this.scopeStack.push(childScope);\n  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\n};\n\npp$5.exitLexicalScope = function () {\n  var childScope = this.scopeStack.pop();\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n  assign(parentScope.childVar, childScope.var, childScope.childVar);\n};\n/**\n * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n * in the current lexical scope or any of the parent lexical scopes in this function.\n */\n\n\npp$5.canDeclareVarName = function (name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name);\n};\n/**\n * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n * any child lexical scopes in this function.\n */\n\n\npp$5.canDeclareLexicalName = function (name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name);\n};\n\npp$5.declareVarName = function (name) {\n  this.scopeStack[this.scopeStack.length - 1].var[name] = true;\n};\n\npp$5.declareLexicalName = function (name) {\n  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n\n  if (parser.options.locations) {\n    this.loc = new SourceLocation(parser, loc);\n  }\n\n  if (parser.options.directSourceFile) {\n    this.sourceFile = parser.options.directSourceFile;\n  }\n\n  if (parser.options.ranges) {\n    this.range = [pos, 0];\n  }\n}; // Start an AST node, attaching a start offset.\n\n\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function () {\n  return new Node(this, this.start, this.startLoc);\n};\n\npp$6.startNodeAt = function (pos, loc) {\n  return new Node(this, pos, loc);\n}; // Finish an AST node, adding `type` and `end` properties.\n\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n\n  if (this.options.locations) {\n    node.loc.end = loc;\n  }\n\n  if (this.options.ranges) {\n    node.range[1] = pos;\n  }\n\n  return node;\n}\n\npp$6.finishNode = function (node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n}; // Finish node at given position\n\n\npp$6.finishNodeAt = function (node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc);\n}; // The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) {\n    return p.tryReadTemplateToken();\n  }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function () {\n  return [types$1.b_stat];\n};\n\npp$7.braceIsBlock = function (prevType) {\n  var parent = this.curContext();\n\n  if (parent === types$1.f_expr || parent === types$1.f_stat) {\n    return true;\n  }\n\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {\n    return !parent.isExpr;\n  } // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n\n\n  if (prevType === types._return || prevType === types.name && this.exprAllowed) {\n    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n  }\n\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {\n    return true;\n  }\n\n  if (prevType === types.braceL) {\n    return parent === types$1.b_stat;\n  }\n\n  if (prevType === types._var || prevType === types.name) {\n    return false;\n  }\n\n  return !this.exprAllowed;\n};\n\npp$7.inGeneratorContext = function () {\n  var this$1 = this;\n\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this$1.context[i];\n\n    if (context.token === \"function\") {\n      return context.generator;\n    }\n  }\n\n  return false;\n};\n\npp$7.updateContext = function (prevType) {\n  var update,\n      type = this.type;\n\n  if (type.keyword && prevType === types.dot) {\n    this.exprAllowed = false;\n  } else if (update = type.updateContext) {\n    update.call(this, prevType);\n  } else {\n    this.exprAllowed = type.beforeExpr;\n  }\n}; // Token-specific context update code\n\n\ntypes.parenR.updateContext = types.braceR.updateContext = function () {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return;\n  }\n\n  var out = this.context.pop();\n\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function (prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function () {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function (prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function () {// tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function (prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {\n    this.context.push(types$1.f_expr);\n  } else {\n    this.context.push(types$1.f_stat);\n  }\n\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function () {\n  if (this.curContext() === types$1.q_tmpl) {\n    this.context.pop();\n  } else {\n    this.context.push(types$1.q_tmpl);\n  }\n\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function (prevType) {\n  if (prevType === types._function) {\n    var index = this.context.length - 1;\n\n    if (this.context[index] === types$1.f_expr) {\n      this.context[index] = types$1.f_expr_gen;\n    } else {\n      this.context[index] = types$1.f_gen;\n    }\n  }\n\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function (prevType) {\n  var allowed = false;\n\n  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n    if (this.value === \"of\" && !this.exprAllowed || this.value === \"yield\" && this.inGeneratorContext()) {\n      allowed = true;\n    }\n  }\n\n  this.exprAllowed = allowed;\n};\n\nvar data = {\n  \"$LONE\": [\"ASCII\", \"ASCII_Hex_Digit\", \"AHex\", \"Alphabetic\", \"Alpha\", \"Any\", \"Assigned\", \"Bidi_Control\", \"Bidi_C\", \"Bidi_Mirrored\", \"Bidi_M\", \"Case_Ignorable\", \"CI\", \"Cased\", \"Changes_When_Casefolded\", \"CWCF\", \"Changes_When_Casemapped\", \"CWCM\", \"Changes_When_Lowercased\", \"CWL\", \"Changes_When_NFKC_Casefolded\", \"CWKCF\", \"Changes_When_Titlecased\", \"CWT\", \"Changes_When_Uppercased\", \"CWU\", \"Dash\", \"Default_Ignorable_Code_Point\", \"DI\", \"Deprecated\", \"Dep\", \"Diacritic\", \"Dia\", \"Emoji\", \"Emoji_Component\", \"Emoji_Modifier\", \"Emoji_Modifier_Base\", \"Emoji_Presentation\", \"Extender\", \"Ext\", \"Grapheme_Base\", \"Gr_Base\", \"Grapheme_Extend\", \"Gr_Ext\", \"Hex_Digit\", \"Hex\", \"IDS_Binary_Operator\", \"IDSB\", \"IDS_Trinary_Operator\", \"IDST\", \"ID_Continue\", \"IDC\", \"ID_Start\", \"IDS\", \"Ideographic\", \"Ideo\", \"Join_Control\", \"Join_C\", \"Logical_Order_Exception\", \"LOE\", \"Lowercase\", \"Lower\", \"Math\", \"Noncharacter_Code_Point\", \"NChar\", \"Pattern_Syntax\", \"Pat_Syn\", \"Pattern_White_Space\", \"Pat_WS\", \"Quotation_Mark\", \"QMark\", \"Radical\", \"Regional_Indicator\", \"RI\", \"Sentence_Terminal\", \"STerm\", \"Soft_Dotted\", \"SD\", \"Terminal_Punctuation\", \"Term\", \"Unified_Ideograph\", \"UIdeo\", \"Uppercase\", \"Upper\", \"Variation_Selector\", \"VS\", \"White_Space\", \"space\", \"XID_Continue\", \"XIDC\", \"XID_Start\", \"XIDS\"],\n  \"General_Category\": [\"Cased_Letter\", \"LC\", \"Close_Punctuation\", \"Pe\", \"Connector_Punctuation\", \"Pc\", \"Control\", \"Cc\", \"cntrl\", \"Currency_Symbol\", \"Sc\", \"Dash_Punctuation\", \"Pd\", \"Decimal_Number\", \"Nd\", \"digit\", \"Enclosing_Mark\", \"Me\", \"Final_Punctuation\", \"Pf\", \"Format\", \"Cf\", \"Initial_Punctuation\", \"Pi\", \"Letter\", \"L\", \"Letter_Number\", \"Nl\", \"Line_Separator\", \"Zl\", \"Lowercase_Letter\", \"Ll\", \"Mark\", \"M\", \"Combining_Mark\", \"Math_Symbol\", \"Sm\", \"Modifier_Letter\", \"Lm\", \"Modifier_Symbol\", \"Sk\", \"Nonspacing_Mark\", \"Mn\", \"Number\", \"N\", \"Open_Punctuation\", \"Ps\", \"Other\", \"C\", \"Other_Letter\", \"Lo\", \"Other_Number\", \"No\", \"Other_Punctuation\", \"Po\", \"Other_Symbol\", \"So\", \"Paragraph_Separator\", \"Zp\", \"Private_Use\", \"Co\", \"Punctuation\", \"P\", \"punct\", \"Separator\", \"Z\", \"Space_Separator\", \"Zs\", \"Spacing_Mark\", \"Mc\", \"Surrogate\", \"Cs\", \"Symbol\", \"S\", \"Titlecase_Letter\", \"Lt\", \"Unassigned\", \"Cn\", \"Uppercase_Letter\", \"Lu\"],\n  \"Script\": [\"Adlam\", \"Adlm\", \"Ahom\", \"Anatolian_Hieroglyphs\", \"Hluw\", \"Arabic\", \"Arab\", \"Armenian\", \"Armn\", \"Avestan\", \"Avst\", \"Balinese\", \"Bali\", \"Bamum\", \"Bamu\", \"Bassa_Vah\", \"Bass\", \"Batak\", \"Batk\", \"Bengali\", \"Beng\", \"Bhaiksuki\", \"Bhks\", \"Bopomofo\", \"Bopo\", \"Brahmi\", \"Brah\", \"Braille\", \"Brai\", \"Buginese\", \"Bugi\", \"Buhid\", \"Buhd\", \"Canadian_Aboriginal\", \"Cans\", \"Carian\", \"Cari\", \"Caucasian_Albanian\", \"Aghb\", \"Chakma\", \"Cakm\", \"Cham\", \"Cherokee\", \"Cher\", \"Common\", \"Zyyy\", \"Coptic\", \"Copt\", \"Qaac\", \"Cuneiform\", \"Xsux\", \"Cypriot\", \"Cprt\", \"Cyrillic\", \"Cyrl\", \"Deseret\", \"Dsrt\", \"Devanagari\", \"Deva\", \"Duployan\", \"Dupl\", \"Egyptian_Hieroglyphs\", \"Egyp\", \"Elbasan\", \"Elba\", \"Ethiopic\", \"Ethi\", \"Georgian\", \"Geor\", \"Glagolitic\", \"Glag\", \"Gothic\", \"Goth\", \"Grantha\", \"Gran\", \"Greek\", \"Grek\", \"Gujarati\", \"Gujr\", \"Gurmukhi\", \"Guru\", \"Han\", \"Hani\", \"Hangul\", \"Hang\", \"Hanunoo\", \"Hano\", \"Hatran\", \"Hatr\", \"Hebrew\", \"Hebr\", \"Hiragana\", \"Hira\", \"Imperial_Aramaic\", \"Armi\", \"Inherited\", \"Zinh\", \"Qaai\", \"Inscriptional_Pahlavi\", \"Phli\", \"Inscriptional_Parthian\", \"Prti\", \"Javanese\", \"Java\", \"Kaithi\", \"Kthi\", \"Kannada\", \"Knda\", \"Katakana\", \"Kana\", \"Kayah_Li\", \"Kali\", \"Kharoshthi\", \"Khar\", \"Khmer\", \"Khmr\", \"Khojki\", \"Khoj\", \"Khudawadi\", \"Sind\", \"Lao\", \"Laoo\", \"Latin\", \"Latn\", \"Lepcha\", \"Lepc\", \"Limbu\", \"Limb\", \"Linear_A\", \"Lina\", \"Linear_B\", \"Linb\", \"Lisu\", \"Lycian\", \"Lyci\", \"Lydian\", \"Lydi\", \"Mahajani\", \"Mahj\", \"Malayalam\", \"Mlym\", \"Mandaic\", \"Mand\", \"Manichaean\", \"Mani\", \"Marchen\", \"Marc\", \"Masaram_Gondi\", \"Gonm\", \"Meetei_Mayek\", \"Mtei\", \"Mende_Kikakui\", \"Mend\", \"Meroitic_Cursive\", \"Merc\", \"Meroitic_Hieroglyphs\", \"Mero\", \"Miao\", \"Plrd\", \"Modi\", \"Mongolian\", \"Mong\", \"Mro\", \"Mroo\", \"Multani\", \"Mult\", \"Myanmar\", \"Mymr\", \"Nabataean\", \"Nbat\", \"New_Tai_Lue\", \"Talu\", \"Newa\", \"Nko\", \"Nkoo\", \"Nushu\", \"Nshu\", \"Ogham\", \"Ogam\", \"Ol_Chiki\", \"Olck\", \"Old_Hungarian\", \"Hung\", \"Old_Italic\", \"Ital\", \"Old_North_Arabian\", \"Narb\", \"Old_Permic\", \"Perm\", \"Old_Persian\", \"Xpeo\", \"Old_South_Arabian\", \"Sarb\", \"Old_Turkic\", \"Orkh\", \"Oriya\", \"Orya\", \"Osage\", \"Osge\", \"Osmanya\", \"Osma\", \"Pahawh_Hmong\", \"Hmng\", \"Palmyrene\", \"Palm\", \"Pau_Cin_Hau\", \"Pauc\", \"Phags_Pa\", \"Phag\", \"Phoenician\", \"Phnx\", \"Psalter_Pahlavi\", \"Phlp\", \"Rejang\", \"Rjng\", \"Runic\", \"Runr\", \"Samaritan\", \"Samr\", \"Saurashtra\", \"Saur\", \"Sharada\", \"Shrd\", \"Shavian\", \"Shaw\", \"Siddham\", \"Sidd\", \"SignWriting\", \"Sgnw\", \"Sinhala\", \"Sinh\", \"Sora_Sompeng\", \"Sora\", \"Soyombo\", \"Soyo\", \"Sundanese\", \"Sund\", \"Syloti_Nagri\", \"Sylo\", \"Syriac\", \"Syrc\", \"Tagalog\", \"Tglg\", \"Tagbanwa\", \"Tagb\", \"Tai_Le\", \"Tale\", \"Tai_Tham\", \"Lana\", \"Tai_Viet\", \"Tavt\", \"Takri\", \"Takr\", \"Tamil\", \"Taml\", \"Tangut\", \"Tang\", \"Telugu\", \"Telu\", \"Thaana\", \"Thaa\", \"Thai\", \"Tibetan\", \"Tibt\", \"Tifinagh\", \"Tfng\", \"Tirhuta\", \"Tirh\", \"Ugaritic\", \"Ugar\", \"Vai\", \"Vaii\", \"Warang_Citi\", \"Wara\", \"Yi\", \"Yiii\", \"Zanabazar_Square\", \"Zanb\"]\n};\nArray.prototype.push.apply(data.$LONE, data.General_Category);\ndata.gc = data.General_Category;\ndata.sc = data.Script_Extensions = data.scx = data.Script;\nvar pp$9 = Parser.prototype;\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = [];\n  this.backReferenceNames = [];\n};\n\nRegExpValidationState.prototype.reset = function reset(start, pattern, flags) {\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n};\n\nRegExpValidationState.prototype.raise = function raise(message) {\n  this.parser.raiseRecoverable(this.start, \"Invalid regular expression: /\" + this.source + \"/: \" + message);\n}; // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n\n\nRegExpValidationState.prototype.at = function at(i) {\n  var s = this.source;\n  var l = s.length;\n\n  if (i >= l) {\n    return -1;\n  }\n\n  var c = s.charCodeAt(i);\n\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c;\n  }\n\n  var next = s.charCodeAt(i + 1);\n  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex(i) {\n  var s = this.source;\n  var l = s.length;\n\n  if (i >= l) {\n    return l;\n  }\n\n  var c = s.charCodeAt(i),\n      next;\n\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n    return i + 1;\n  }\n\n  return i + 2;\n};\n\nRegExpValidationState.prototype.current = function current() {\n  return this.at(this.pos);\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead() {\n  return this.at(this.nextIndex(this.pos));\n};\n\nRegExpValidationState.prototype.advance = function advance() {\n  this.pos = this.nextIndex(this.pos);\n};\n\nRegExpValidationState.prototype.eat = function eat(ch) {\n  if (this.current() === ch) {\n    this.advance();\n    return true;\n  }\n\n  return false;\n};\n\nfunction codePointToString$1(ch) {\n  if (ch <= 0xFFFF) {\n    return String.fromCharCode(ch);\n  }\n\n  ch -= 0x10000;\n  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00);\n}\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\n\n\npp$9.validateRegExpFlags = function (state) {\n  var this$1 = this;\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n\n    if (validFlags.indexOf(flag) === -1) {\n      this$1.raise(state.start, \"Invalid regular expression flag\");\n    }\n\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this$1.raise(state.start, \"Duplicate regular expression flag\");\n    }\n  }\n};\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\n\n\npp$9.validateRegExpPattern = function (state) {\n  this.regexp_pattern(state); // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n\n  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n\n\npp$9.regexp_pattern = function (state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames.length = 0;\n  state.backReferenceNames.length = 0;\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29\n    /* ) */\n    )) {\n      state.raise(\"Unmatched ')'\");\n    }\n\n    if (state.eat(0x5D\n    /* [ */\n    ) || state.eat(0x7D\n    /* } */\n    )) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (state.groupNames.indexOf(name) === -1) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n\n\npp$9.regexp_disjunction = function (state) {\n  var this$1 = this;\n  this.regexp_alternative(state);\n\n  while (state.eat(0x7C\n  /* | */\n  )) {\n    this$1.regexp_alternative(state);\n  } // Make the same message as V8.\n\n\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n\n  if (state.eat(0x7B\n  /* { */\n  )) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n\n\npp$9.regexp_alternative = function (state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n\n\npp$9.regexp_eatTerm = function (state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n\n    return true;\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true;\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n\n\npp$9.regexp_eatAssertion = function (state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false; // ^, $\n\n  if (state.eat(0x5E\n  /* ^ */\n  ) || state.eat(0x24\n  /* $ */\n  )) {\n    return true;\n  } // \\b \\B\n\n\n  if (state.eat(0x5C\n  /* \\ */\n  )) {\n    if (state.eat(0x42\n    /* B */\n    ) || state.eat(0x62\n    /* b */\n    )) {\n      return true;\n    }\n\n    state.pos = start;\n  } // Lookahead / Lookbehind\n\n\n  if (state.eat(0x28\n  /* ( */\n  ) && state.eat(0x3F\n  /* ? */\n  )) {\n    var lookbehind = false;\n\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C\n      /* < */\n      );\n    }\n\n    if (state.eat(0x3D\n    /* = */\n    ) || state.eat(0x21\n    /* ! */\n    )) {\n      this.regexp_disjunction(state);\n\n      if (!state.eat(0x29\n      /* ) */\n      )) {\n        state.raise(\"Unterminated group\");\n      }\n\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true;\n    }\n  }\n\n  state.pos = start;\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n\n\npp$9.regexp_eatQuantifier = function (state, noError) {\n  if (noError === void 0) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F\n    /* ? */\n    );\n    return true;\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n\n\npp$9.regexp_eatQuantifierPrefix = function (state, noError) {\n  return state.eat(0x2A\n  /* * */\n  ) || state.eat(0x2B\n  /* + */\n  ) || state.eat(0x3F\n  /* ? */\n  ) || this.regexp_eatBracedQuantifier(state, noError);\n};\n\npp$9.regexp_eatBracedQuantifier = function (state, noError) {\n  var start = state.pos;\n\n  if (state.eat(0x7B\n  /* { */\n  )) {\n    var min = 0,\n        max = -1;\n\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n\n      if (state.eat(0x2C\n      /* , */\n      ) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n\n      if (state.eat(0x7D\n      /* } */\n      )) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n\n        return true;\n      }\n    }\n\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n\n    state.pos = start;\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n\n\npp$9.regexp_eatAtom = function (state) {\n  return this.regexp_eatPatternCharacters(state) || state.eat(0x2E\n  /* . */\n  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);\n};\n\npp$9.regexp_eatReverseSolidusAtomEscape = function (state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C\n  /* \\ */\n  )) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true;\n    }\n\n    state.pos = start;\n  }\n\n  return false;\n};\n\npp$9.regexp_eatUncapturingGroup = function (state) {\n  var start = state.pos;\n\n  if (state.eat(0x28\n  /* ( */\n  )) {\n    if (state.eat(0x3F\n    /* ? */\n    ) && state.eat(0x3A\n    /* : */\n    )) {\n      this.regexp_disjunction(state);\n\n      if (state.eat(0x29\n      /* ) */\n      )) {\n        return true;\n      }\n\n      state.raise(\"Unterminated group\");\n    }\n\n    state.pos = start;\n  }\n\n  return false;\n};\n\npp$9.regexp_eatCapturingGroup = function (state) {\n  if (state.eat(0x28\n  /* ( */\n  )) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F\n    /* ? */\n    ) {\n        state.raise(\"Invalid group\");\n      }\n\n    this.regexp_disjunction(state);\n\n    if (state.eat(0x29\n    /* ) */\n    )) {\n      state.numCapturingParens += 1;\n      return true;\n    }\n\n    state.raise(\"Unterminated group\");\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n\n\npp$9.regexp_eatExtendedAtom = function (state) {\n  return state.eat(0x2E\n  /* . */\n  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n\n\npp$9.regexp_eatInvalidBracedQuantifier = function (state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n\n\npp$9.regexp_eatSyntaxCharacter = function (state) {\n  var ch = state.current();\n\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true;\n  }\n\n  return false;\n};\n\nfunction isSyntaxCharacter(ch) {\n  return ch === 0x24\n  /* $ */\n  || ch >= 0x28\n  /* ( */\n  && ch <= 0x2B\n  /* + */\n  || ch === 0x2E\n  /* . */\n  || ch === 0x3F\n  /* ? */\n  || ch >= 0x5B\n  /* [ */\n  && ch <= 0x5E\n  /* ^ */\n  || ch >= 0x7B\n  /* { */\n  && ch <= 0x7D\n  /* } */\n  ;\n} // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\n\n\npp$9.regexp_eatPatternCharacters = function (state) {\n  var start = state.pos;\n  var ch = 0;\n\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n\n  return state.pos !== start;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n\n\npp$9.regexp_eatExtendedPatternCharacter = function (state) {\n  var ch = state.current();\n\n  if (ch !== -1 && ch !== 0x24\n  /* $ */\n  && !(ch >= 0x28\n  /* ( */\n  && ch <= 0x2B\n  /* + */\n  ) && ch !== 0x2E\n  /* . */\n  && ch !== 0x3F\n  /* ? */\n  && ch !== 0x5B\n  /* [ */\n  && ch !== 0x5E\n  /* ^ */\n  && ch !== 0x7C\n  /* | */\n  ) {\n      state.advance();\n      return true;\n    }\n\n  return false;\n}; // GroupSpecifier[U] ::\n//   [empty]\n//   `?` GroupName[?U]\n\n\npp$9.regexp_groupSpecifier = function (state) {\n  if (state.eat(0x3F\n  /* ? */\n  )) {\n    if (this.regexp_eatGroupName(state)) {\n      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n        state.raise(\"Duplicate capture group name\");\n      }\n\n      state.groupNames.push(state.lastStringValue);\n      return;\n    }\n\n    state.raise(\"Invalid group\");\n  }\n}; // GroupName[U] ::\n//   `<` RegExpIdentifierName[?U] `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\n\n\npp$9.regexp_eatGroupName = function (state) {\n  state.lastStringValue = \"\";\n\n  if (state.eat(0x3C\n  /* < */\n  )) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E\n    /* > */\n    )) {\n      return true;\n    }\n\n    state.raise(\"Invalid capture group name\");\n  }\n\n  return false;\n}; // RegExpIdentifierName[U] ::\n//   RegExpIdentifierStart[?U]\n//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n// Note: this updates `state.lastStringValue` property with the eaten name.\n\n\npp$9.regexp_eatRegExpIdentifierName = function (state) {\n  state.lastStringValue = \"\";\n\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString$1(state.lastIntValue);\n\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString$1(state.lastIntValue);\n    }\n\n    return true;\n  }\n\n  return false;\n}; // RegExpIdentifierStart[U] ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\n\n\npp$9.regexp_eatRegExpIdentifierStart = function (state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C\n  /* \\ */\n  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true;\n  }\n\n  state.pos = start;\n  return false;\n};\n\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24\n  /* $ */\n  || ch === 0x5F;\n  /* _ */\n} // RegExpIdentifierPart[U] ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\n//   <ZWNJ>\n//   <ZWJ>\n\n\npp$9.regexp_eatRegExpIdentifierPart = function (state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C\n  /* \\ */\n  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true;\n  }\n\n  state.pos = start;\n  return false;\n};\n\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24\n  /* $ */\n  || ch === 0x5F\n  /* _ */\n  || ch === 0x200C\n  /* <ZWNJ> */\n  || ch === 0x200D;\n  /* <ZWJ> */\n} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n\n\npp$9.regexp_eatAtomEscape = function (state) {\n  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {\n    return true;\n  }\n\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63\n    /* c */\n    ) {\n        state.raise(\"Invalid unicode escape\");\n      }\n\n    state.raise(\"Invalid escape\");\n  }\n\n  return false;\n};\n\npp$9.regexp_eatBackReference = function (state) {\n  var start = state.pos;\n\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n\n      return true;\n    }\n\n    if (n <= state.numCapturingParens) {\n      return true;\n    }\n\n    state.pos = start;\n  }\n\n  return false;\n};\n\npp$9.regexp_eatKGroupName = function (state) {\n  if (state.eat(0x6B\n  /* k */\n  )) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true;\n    }\n\n    state.raise(\"Invalid named reference\");\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n\n\npp$9.regexp_eatCharacterEscape = function (state) {\n  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);\n};\n\npp$9.regexp_eatCControlLetter = function (state) {\n  var start = state.pos;\n\n  if (state.eat(0x63\n  /* c */\n  )) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true;\n    }\n\n    state.pos = start;\n  }\n\n  return false;\n};\n\npp$9.regexp_eatZero = function (state) {\n  if (state.current() === 0x30\n  /* 0 */\n  && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true;\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n\n\npp$9.regexp_eatControlEscape = function (state) {\n  var ch = state.current();\n\n  if (ch === 0x74\n  /* t */\n  ) {\n      state.lastIntValue = 0x09;\n      /* \\t */\n\n      state.advance();\n      return true;\n    }\n\n  if (ch === 0x6E\n  /* n */\n  ) {\n      state.lastIntValue = 0x0A;\n      /* \\n */\n\n      state.advance();\n      return true;\n    }\n\n  if (ch === 0x76\n  /* v */\n  ) {\n      state.lastIntValue = 0x0B;\n      /* \\v */\n\n      state.advance();\n      return true;\n    }\n\n  if (ch === 0x66\n  /* f */\n  ) {\n      state.lastIntValue = 0x0C;\n      /* \\f */\n\n      state.advance();\n      return true;\n    }\n\n  if (ch === 0x72\n  /* r */\n  ) {\n      state.lastIntValue = 0x0D;\n      /* \\r */\n\n      state.advance();\n      return true;\n    }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n\n\npp$9.regexp_eatControlLetter = function (state) {\n  var ch = state.current();\n\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true;\n  }\n\n  return false;\n};\n\nfunction isControlLetter(ch) {\n  return ch >= 0x41\n  /* A */\n  && ch <= 0x5A\n  /* Z */\n  || ch >= 0x61\n  /* a */\n  && ch <= 0x7A\n  /* z */\n  ;\n} // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n\n\npp$9.regexp_eatRegExpUnicodeEscapeSequence = function (state) {\n  var start = state.pos;\n\n  if (state.eat(0x75\n  /* u */\n  )) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n\n      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n\n        if (state.eat(0x5C\n        /* \\ */\n        ) && state.eat(0x75\n        /* u */\n        ) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true;\n          }\n        }\n\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n\n      return true;\n    }\n\n    if (state.switchU && state.eat(0x7B\n    /* { */\n    ) && this.regexp_eatHexDigits(state) && state.eat(0x7D\n    /* } */\n    ) && isValidUnicode(state.lastIntValue)) {\n      return true;\n    }\n\n    if (state.switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n\n    state.pos = start;\n  }\n\n  return false;\n};\n\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF;\n} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n\n\npp$9.regexp_eatIdentityEscape = function (state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true;\n    }\n\n    if (state.eat(0x2F\n    /* / */\n    )) {\n      state.lastIntValue = 0x2F;\n      /* / */\n\n      return true;\n    }\n\n    return false;\n  }\n\n  var ch = state.current();\n\n  if (ch !== 0x63\n  /* c */\n  && (!state.switchN || ch !== 0x6B\n  /* k */\n  )) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true;\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n\n\npp$9.regexp_eatDecimalEscape = function (state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n\n  if (ch >= 0x31\n  /* 1 */\n  && ch <= 0x39\n  /* 9 */\n  ) {\n      do {\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30\n        /* 0 */\n        );\n        state.advance();\n      } while ((ch = state.current()) >= 0x30\n      /* 0 */\n      && ch <= 0x39\n      /* 9 */\n      );\n\n      return true;\n    }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n\n\npp$9.regexp_eatCharacterClassEscape = function (state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return true;\n  }\n\n  if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 0x50\n  /* P */\n  || ch === 0x70\n  /* p */\n  )) {\n    state.lastIntValue = -1;\n    state.advance();\n\n    if (state.eat(0x7B\n    /* { */\n    ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(0x7D\n    /* } */\n    )) {\n      return true;\n    }\n\n    state.raise(\"Invalid property name\");\n  }\n\n  return false;\n};\n\nfunction isCharacterClassEscape(ch) {\n  return ch === 0x64\n  /* d */\n  || ch === 0x44\n  /* D */\n  || ch === 0x73\n  /* s */\n  || ch === 0x53\n  /* S */\n  || ch === 0x77\n  /* w */\n  || ch === 0x57\n  /* W */\n  ;\n} // UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\n\n\npp$9.regexp_eatUnicodePropertyValueExpression = function (state) {\n  var start = state.pos; // UnicodePropertyName `=` UnicodePropertyValue\n\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D\n  /* = */\n  )) {\n    var name = state.lastStringValue;\n\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return true;\n    }\n  }\n\n  state.pos = start; // LoneUnicodePropertyNameOrValue\n\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    return true;\n  }\n\n  return false;\n};\n\npp$9.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {\n  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {\n    state.raise(\"Invalid property name\");\n  }\n};\n\npp$9.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {\n  if (data.$LONE.indexOf(nameOrValue) === -1) {\n    state.raise(\"Invalid property name\");\n  }\n}; // UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\n\n\npp$9.regexp_eatUnicodePropertyName = function (state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString$1(ch);\n    state.advance();\n  }\n\n  return state.lastStringValue !== \"\";\n};\n\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F;\n  /* _ */\n} // UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\n\n\npp$9.regexp_eatUnicodePropertyValue = function (state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString$1(ch);\n    state.advance();\n  }\n\n  return state.lastStringValue !== \"\";\n};\n\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);\n} // LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\n\n\npp$9.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {\n  return this.regexp_eatUnicodePropertyValue(state);\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n\n\npp$9.regexp_eatCharacterClass = function (state) {\n  if (state.eat(0x5B\n  /* [ */\n  )) {\n    state.eat(0x5E\n    /* ^ */\n    );\n    this.regexp_classRanges(state);\n\n    if (state.eat(0x5D\n    /* [ */\n    )) {\n      return true;\n    } // Unreachable since it threw \"unterminated regular expression\" error before.\n\n\n    state.raise(\"Unterminated character class\");\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n\n\npp$9.regexp_classRanges = function (state) {\n  var this$1 = this;\n\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n\n    if (state.eat(0x2D\n    /* - */\n    ) && this$1.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n\n\npp$9.regexp_eatClassAtom = function (state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C\n  /* \\ */\n  )) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true;\n    }\n\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n\n      if (ch$1 === 0x63\n      /* c */\n      || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n\n      state.raise(\"Invalid escape\");\n    }\n\n    state.pos = start;\n  }\n\n  var ch = state.current();\n\n  if (ch !== 0x5D\n  /* [ */\n  ) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true;\n    }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n\n\npp$9.regexp_eatClassEscape = function (state) {\n  var start = state.pos;\n\n  if (state.eat(0x62\n  /* b */\n  )) {\n    state.lastIntValue = 0x08;\n    /* <BS> */\n\n    return true;\n  }\n\n  if (state.switchU && state.eat(0x2D\n  /* - */\n  )) {\n    state.lastIntValue = 0x2D;\n    /* - */\n\n    return true;\n  }\n\n  if (!state.switchU && state.eat(0x63\n  /* c */\n  )) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true;\n    }\n\n    state.pos = start;\n  }\n\n  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n\n\npp$9.regexp_eatClassControlLetter = function (state) {\n  var ch = state.current();\n\n  if (isDecimalDigit(ch) || ch === 0x5F\n  /* _ */\n  ) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true;\n    }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n\n\npp$9.regexp_eatHexEscapeSequence = function (state) {\n  var start = state.pos;\n\n  if (state.eat(0x78\n  /* x */\n  )) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true;\n    }\n\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n\n    state.pos = start;\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n\n\npp$9.regexp_eatDecimalDigits = function (state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30\n    /* 0 */\n    );\n    state.advance();\n  }\n\n  return state.pos !== start;\n};\n\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30\n  /* 0 */\n  && ch <= 0x39;\n  /* 9 */\n} // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n\n\npp$9.regexp_eatHexDigits = function (state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n\n  return state.pos !== start;\n};\n\nfunction isHexDigit(ch) {\n  return ch >= 0x30\n  /* 0 */\n  && ch <= 0x39\n  /* 9 */\n  || ch >= 0x41\n  /* A */\n  && ch <= 0x46\n  /* F */\n  || ch >= 0x61\n  /* a */\n  && ch <= 0x66\n  /* f */\n  ;\n}\n\nfunction hexToInt(ch) {\n  if (ch >= 0x41\n  /* A */\n  && ch <= 0x46\n  /* F */\n  ) {\n      return 10 + (ch - 0x41\n      /* A */\n      );\n    }\n\n  if (ch >= 0x61\n  /* a */\n  && ch <= 0x66\n  /* f */\n  ) {\n      return 10 + (ch - 0x61\n      /* a */\n      );\n    }\n\n  return ch - 0x30;\n  /* 0 */\n} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\n\n\npp$9.regexp_eatLegacyOctalEscapeSequence = function (state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n\n    return true;\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n\n\npp$9.regexp_eatOctalDigit = function (state) {\n  var ch = state.current();\n\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30;\n    /* 0 */\n\n    state.advance();\n    return true;\n  }\n\n  state.lastIntValue = 0;\n  return false;\n};\n\nfunction isOctalDigit(ch) {\n  return ch >= 0x30\n  /* 0 */\n  && ch <= 0x37;\n  /* 7 */\n} // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n\n\npp$9.regexp_eatFixedHexDigits = function (state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false;\n    }\n\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n\n  return true;\n}; // Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n\n  if (p.options.locations) {\n    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);\n  }\n\n  if (p.options.ranges) {\n    this.range = [p.start, p.end];\n  }\n}; // ## Tokenizer\n\n\nvar pp$8 = Parser.prototype; // Move to the next token\n\npp$8.next = function () {\n  if (this.options.onToken) {\n    this.options.onToken(new Token(this));\n  }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$8.getToken = function () {\n  this.next();\n  return new Token(this);\n}; // If we're in an ES6 environment, make parsers iterable\n\n\nif (typeof Symbol !== \"undefined\") {\n  pp$8[Symbol.iterator] = function () {\n    var this$1 = this;\n    return {\n      next: function next() {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        };\n      }\n    };\n  };\n} // Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\n\npp$8.curContext = function () {\n  return this.context[this.context.length - 1];\n}; // Read a single token, updating the parser object's token-related\n// properties.\n\n\npp$8.nextToken = function () {\n  var curContext = this.curContext();\n\n  if (!curContext || !curContext.preserveSpace) {\n    this.skipSpace();\n  }\n\n  this.start = this.pos;\n\n  if (this.options.locations) {\n    this.startLoc = this.curPosition();\n  }\n\n  if (this.pos >= this.input.length) {\n    return this.finishToken(types.eof);\n  }\n\n  if (curContext.override) {\n    return curContext.override(this);\n  } else {\n    this.readToken(this.fullCharCodeAtPos());\n  }\n};\n\npp$8.readToken = function (code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92\n  /* '\\' */\n  ) {\n      return this.readWord();\n    }\n\n  return this.getTokenFromCode(code);\n};\n\npp$8.fullCharCodeAtPos = function () {\n  var code = this.input.charCodeAt(this.pos);\n\n  if (code <= 0xd7ff || code >= 0xe000) {\n    return code;\n  }\n\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00;\n};\n\npp$8.skipBlockComment = function () {\n  var this$1 = this;\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos,\n      end = this.input.indexOf(\"*/\", this.pos += 2);\n\n  if (end === -1) {\n    this.raise(this.pos - 2, \"Unterminated comment\");\n  }\n\n  this.pos = end + 2;\n\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine;\n      this$1.lineStart = match.index + match[0].length;\n    }\n  }\n\n  if (this.options.onComment) {\n    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n  }\n};\n\npp$8.skipLineComment = function (startSkip) {\n  var this$1 = this;\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this$1.input.charCodeAt(++this$1.pos);\n  }\n\n  if (this.options.onComment) {\n    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n  }\n}; // Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\n\npp$8.skipSpace = function () {\n  var this$1 = this;\n\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos);\n\n    switch (ch) {\n      case 32:\n      case 160:\n        // ' '\n        ++this$1.pos;\n        break;\n\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n          ++this$1.pos;\n        }\n\n      case 10:\n      case 8232:\n      case 8233:\n        ++this$1.pos;\n\n        if (this$1.options.locations) {\n          ++this$1.curLine;\n          this$1.lineStart = this$1.pos;\n        }\n\n        break;\n\n      case 47:\n        // '/'\n        switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n          case 42:\n            // '*'\n            this$1.skipBlockComment();\n            break;\n\n          case 47:\n            this$1.skipLineComment(2);\n            break;\n\n          default:\n            break loop;\n        }\n\n        break;\n\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this$1.pos;\n        } else {\n          break loop;\n        }\n\n    }\n  }\n}; // Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\n\npp$8.finishToken = function (type, val) {\n  this.end = this.pos;\n\n  if (this.options.locations) {\n    this.endLoc = this.curPosition();\n  }\n\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n  this.updateContext(prevType);\n}; // ### Token reading\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\n\n\npp$8.readToken_dot = function () {\n  var next = this.input.charCodeAt(this.pos + 1);\n\n  if (next >= 48 && next <= 57) {\n    return this.readNumber(true);\n  }\n\n  var next2 = this.input.charCodeAt(this.pos + 2);\n\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n    // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis);\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot);\n  }\n};\n\npp$8.readToken_slash = function () {\n  // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n\n  if (this.exprAllowed) {\n    ++this.pos;\n    return this.readRegexp();\n  }\n\n  if (next === 61) {\n    return this.finishOp(types.assign, 2);\n  }\n\n  return this.finishOp(types.slash, 1);\n};\n\npp$8.readToken_mult_modulo_exp = function (code) {\n  // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo; // exponentiation operator ** and **=\n\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) {\n    return this.finishOp(types.assign, size + 1);\n  }\n\n  return this.finishOp(tokentype, size);\n};\n\npp$8.readToken_pipe_amp = function (code) {\n  // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n\n  if (next === code) {\n    return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);\n  }\n\n  if (next === 61) {\n    return this.finishOp(types.assign, 2);\n  }\n\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);\n};\n\npp$8.readToken_caret = function () {\n  // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n\n  if (next === 61) {\n    return this.finishOp(types.assign, 2);\n  }\n\n  return this.finishOp(types.bitwiseXOR, 1);\n};\n\npp$8.readToken_plus_min = function (code) {\n  // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken();\n    }\n\n    return this.finishOp(types.incDec, 2);\n  }\n\n  if (next === 61) {\n    return this.finishOp(types.assign, 2);\n  }\n\n  return this.finishOp(types.plusMin, 1);\n};\n\npp$8.readToken_lt_gt = function (code) {\n  // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n\n    if (this.input.charCodeAt(this.pos + size) === 61) {\n      return this.finishOp(types.assign, size + 1);\n    }\n\n    return this.finishOp(types.bitShift, size);\n  }\n\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken();\n  }\n\n  if (next === 61) {\n    size = 2;\n  }\n\n  return this.finishOp(types.relational, size);\n};\n\npp$8.readToken_eq_excl = function (code) {\n  // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n\n  if (next === 61) {\n    return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n  }\n\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n    // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow);\n  }\n\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1);\n};\n\npp$8.getTokenFromCode = function (code) {\n  switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n    case 46:\n      // '.'\n      return this.readToken_dot();\n    // Punctuation tokens.\n\n    case 40:\n      ++this.pos;\n      return this.finishToken(types.parenL);\n\n    case 41:\n      ++this.pos;\n      return this.finishToken(types.parenR);\n\n    case 59:\n      ++this.pos;\n      return this.finishToken(types.semi);\n\n    case 44:\n      ++this.pos;\n      return this.finishToken(types.comma);\n\n    case 91:\n      ++this.pos;\n      return this.finishToken(types.bracketL);\n\n    case 93:\n      ++this.pos;\n      return this.finishToken(types.bracketR);\n\n    case 123:\n      ++this.pos;\n      return this.finishToken(types.braceL);\n\n    case 125:\n      ++this.pos;\n      return this.finishToken(types.braceR);\n\n    case 58:\n      ++this.pos;\n      return this.finishToken(types.colon);\n\n    case 63:\n      ++this.pos;\n      return this.finishToken(types.question);\n\n    case 96:\n      // '`'\n      if (this.options.ecmaVersion < 6) {\n        break;\n      }\n\n      ++this.pos;\n      return this.finishToken(types.backQuote);\n\n    case 48:\n      // '0'\n      var next = this.input.charCodeAt(this.pos + 1);\n\n      if (next === 120 || next === 88) {\n        return this.readRadixNumber(16);\n      } // '0x', '0X' - hex number\n\n\n      if (this.options.ecmaVersion >= 6) {\n        if (next === 111 || next === 79) {\n          return this.readRadixNumber(8);\n        } // '0o', '0O' - octal number\n\n\n        if (next === 98 || next === 66) {\n          return this.readRadixNumber(2);\n        } // '0b', '0B' - binary number\n\n      }\n\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      // 1-9\n      return this.readNumber(false);\n    // Quotes produce strings.\n\n    case 34:\n    case 39:\n      // '\"', \"'\"\n      return this.readString(code);\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case 47:\n      // '/'\n      return this.readToken_slash();\n\n    case 37:\n    case 42:\n      // '%*'\n      return this.readToken_mult_modulo_exp(code);\n\n    case 124:\n    case 38:\n      // '|&'\n      return this.readToken_pipe_amp(code);\n\n    case 94:\n      // '^'\n      return this.readToken_caret();\n\n    case 43:\n    case 45:\n      // '+-'\n      return this.readToken_plus_min(code);\n\n    case 60:\n    case 62:\n      // '<>'\n      return this.readToken_lt_gt(code);\n\n    case 61:\n    case 33:\n      // '=!'\n      return this.readToken_eq_excl(code);\n\n    case 126:\n      // '~'\n      return this.finishOp(types.prefix, 1);\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp$8.finishOp = function (type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str);\n};\n\npp$8.readRegexp = function () {\n  var this$1 = this;\n  var escaped,\n      inClass,\n      start = this.pos;\n\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) {\n      this$1.raise(start, \"Unterminated regular expression\");\n    }\n\n    var ch = this$1.input.charAt(this$1.pos);\n\n    if (lineBreak.test(ch)) {\n      this$1.raise(start, \"Unterminated regular expression\");\n    }\n\n    if (!escaped) {\n      if (ch === \"[\") {\n        inClass = true;\n      } else if (ch === \"]\" && inClass) {\n        inClass = false;\n      } else if (ch === \"/\" && !inClass) {\n        break;\n      }\n\n      escaped = ch === \"\\\\\";\n    } else {\n      escaped = false;\n    }\n\n    ++this$1.pos;\n  }\n\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n\n  if (this.containsEsc) {\n    this.unexpected(flagsStart);\n  } // Validate pattern\n\n\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state); // Create Literal#value property value.\n\n  var value = null;\n\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {// ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types.regexp, {\n    pattern: pattern,\n    flags: flags,\n    value: value\n  });\n}; // Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\n\npp$8.readInt = function (radix, len) {\n  var this$1 = this;\n  var start = this.pos,\n      total = 0;\n\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos),\n        val = void 0;\n\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } // a\n    else if (code >= 65) {\n        val = code - 65 + 10;\n      } // A\n      else if (code >= 48 && code <= 57) {\n          val = code - 48;\n        } // 0-9\n        else {\n            val = Infinity;\n          }\n\n    if (val >= radix) {\n      break;\n    }\n\n    ++this$1.pos;\n    total = total * radix + val;\n  }\n\n  if (this.pos === start || len != null && this.pos - start !== len) {\n    return null;\n  }\n\n  return total;\n};\n\npp$8.readRadixNumber = function (radix) {\n  this.pos += 2; // 0x\n\n  var val = this.readInt(radix);\n\n  if (val == null) {\n    this.raise(this.start + 2, \"Expected number in radix \" + radix);\n  }\n\n  if (isIdentifierStart(this.fullCharCodeAtPos())) {\n    this.raise(this.pos, \"Identifier directly after number\");\n  }\n\n  return this.finishToken(types.num, val);\n}; // Read an integer, octal integer, or floating-point number.\n\n\npp$8.readNumber = function (startsWithDot) {\n  var start = this.pos;\n\n  if (!startsWithDot && this.readInt(10) === null) {\n    this.raise(start, \"Invalid number\");\n  }\n\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n\n  if (octal && this.strict) {\n    this.raise(start, \"Invalid number\");\n  }\n\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {\n    octal = false;\n  }\n\n  var next = this.input.charCodeAt(this.pos);\n\n  if (next === 46 && !octal) {\n    // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n\n  if ((next === 69 || next === 101) && !octal) {\n    // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n\n    if (next === 43 || next === 45) {\n      ++this.pos;\n    } // '+-'\n\n\n    if (this.readInt(10) === null) {\n      this.raise(start, \"Invalid number\");\n    }\n  }\n\n  if (isIdentifierStart(this.fullCharCodeAtPos())) {\n    this.raise(this.pos, \"Identifier directly after number\");\n  }\n\n  var str = this.input.slice(start, this.pos);\n  var val = octal ? parseInt(str, 8) : parseFloat(str);\n  return this.finishToken(types.num, val);\n}; // Read a string value, interpreting backslash-escapes.\n\n\npp$8.readCodePoint = function () {\n  var ch = this.input.charCodeAt(this.pos),\n      code;\n\n  if (ch === 123) {\n    // '{'\n    if (this.options.ecmaVersion < 6) {\n      this.unexpected();\n    }\n\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n\n    if (code > 0x10FFFF) {\n      this.invalidStringToken(codePos, \"Code point out of bounds\");\n    }\n  } else {\n    code = this.readHexChar(4);\n  }\n\n  return code;\n};\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) {\n    return String.fromCharCode(code);\n  }\n\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n}\n\npp$8.readString = function (quote) {\n  var this$1 = this;\n  var out = \"\",\n      chunkStart = ++this.pos;\n\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) {\n      this$1.raise(this$1.start, \"Unterminated string constant\");\n    }\n\n    var ch = this$1.input.charCodeAt(this$1.pos);\n\n    if (ch === quote) {\n      break;\n    }\n\n    if (ch === 92) {\n      // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(false);\n      chunkStart = this$1.pos;\n    } else {\n      if (isNewLine(ch, this$1.options.ecmaVersion >= 10)) {\n        this$1.raise(this$1.start, \"Unterminated string constant\");\n      }\n\n      ++this$1.pos;\n    }\n  }\n\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out);\n}; // Reads template string tokens.\n\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$8.tryReadTemplateToken = function () {\n  this.inTemplateElement = true;\n\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err;\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$8.invalidStringToken = function (position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR;\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$8.readTmplToken = function () {\n  var this$1 = this;\n  var out = \"\",\n      chunkStart = this.pos;\n\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) {\n      this$1.raise(this$1.start, \"Unterminated template\");\n    }\n\n    var ch = this$1.input.charCodeAt(this$1.pos);\n\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) {\n      // '`', '${'\n      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this$1.pos += 2;\n          return this$1.finishToken(types.dollarBraceL);\n        } else {\n          ++this$1.pos;\n          return this$1.finishToken(types.backQuote);\n        }\n      }\n\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      return this$1.finishToken(types.template, out);\n    }\n\n    if (ch === 92) {\n      // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(true);\n      chunkStart = this$1.pos;\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      ++this$1.pos;\n\n      switch (ch) {\n        case 13:\n          if (this$1.input.charCodeAt(this$1.pos) === 10) {\n            ++this$1.pos;\n          }\n\n        case 10:\n          out += \"\\n\";\n          break;\n\n        default:\n          out += String.fromCharCode(ch);\n          break;\n      }\n\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n\n      chunkStart = this$1.pos;\n    } else {\n      ++this$1.pos;\n    }\n  }\n}; // Reads a template token to search for the end, without validating any escape sequences\n\n\npp$8.readInvalidTemplateToken = function () {\n  var this$1 = this;\n\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this$1.input[this$1.pos]) {\n      case \"\\\\\":\n        ++this$1.pos;\n        break;\n\n      case \"$\":\n        if (this$1.input[this$1.pos + 1] !== \"{\") {\n          break;\n        }\n\n      // falls through\n\n      case \"`\":\n        return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos));\n      // no default\n    }\n  }\n\n  this.raise(this.start, \"Unterminated template\");\n}; // Used to read escaped characters\n\n\npp$8.readEscapedChar = function (inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n\n  switch (ch) {\n    case 110:\n      return \"\\n\";\n    // 'n' -> '\\n'\n\n    case 114:\n      return \"\\r\";\n    // 'r' -> '\\r'\n\n    case 120:\n      return String.fromCharCode(this.readHexChar(2));\n    // 'x'\n\n    case 117:\n      return codePointToString(this.readCodePoint());\n    // 'u'\n\n    case 116:\n      return \"\\t\";\n    // 't' -> '\\t'\n\n    case 98:\n      return \"\\b\";\n    // 'b' -> '\\b'\n\n    case 118:\n      return \"\\x0B\";\n    // 'v' -> '\\u000b'\n\n    case 102:\n      return \"\\f\";\n    // 'f' -> '\\f'\n\n    case 13:\n      if (this.input.charCodeAt(this.pos) === 10) {\n        ++this.pos;\n      }\n\n    // '\\r\\n'\n\n    case 10:\n      // ' \\n'\n      if (this.options.locations) {\n        this.lineStart = this.pos;\n        ++this.curLine;\n      }\n\n      return \"\";\n\n    default:\n      if (ch >= 48 && ch <= 55) {\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n        var octal = parseInt(octalStr, 8);\n\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n\n        this.pos += octalStr.length - 1;\n        ch = this.input.charCodeAt(this.pos);\n\n        if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n          this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? \"Octal literal in template string\" : \"Octal literal in strict mode\");\n        }\n\n        return String.fromCharCode(octal);\n      }\n\n      return String.fromCharCode(ch);\n  }\n}; // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n\npp$8.readHexChar = function (len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n\n  if (n === null) {\n    this.invalidStringToken(codePos, \"Bad character escape sequence\");\n  }\n\n  return n;\n}; // Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\n\npp$8.readWord1 = function () {\n  var this$1 = this;\n  this.containsEsc = false;\n  var word = \"\",\n      first = true,\n      chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos();\n\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) {\n      // \"\\\"\n      this$1.containsEsc = true;\n      word += this$1.input.slice(chunkStart, this$1.pos);\n      var escStart = this$1.pos;\n\n      if (this$1.input.charCodeAt(++this$1.pos) !== 117) // \"u\"\n        {\n          this$1.invalidStringToken(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        }\n\n      ++this$1.pos;\n      var esc = this$1.readCodePoint();\n\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {\n        this$1.invalidStringToken(escStart, \"Invalid Unicode escape\");\n      }\n\n      word += codePointToString(esc);\n      chunkStart = this$1.pos;\n    } else {\n      break;\n    }\n\n    first = false;\n  }\n\n  return word + this.input.slice(chunkStart, this.pos);\n}; // Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\n\npp$8.readWord = function () {\n  var word = this.readWord1();\n  var type = types.name;\n\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) {\n      this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word);\n    }\n\n    type = keywords$1[word];\n  }\n\n  return this.finishToken(type, word);\n}; // Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/acornjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/acornjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\n\nvar version = \"5.7.3\"; // The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse();\n} // This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos);\n  p.nextToken();\n  return p.parseExpression();\n} // Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input);\n} // This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\n\n\nvar parse_dammit;\nvar LooseParser;\nvar pluginsLoose; // eslint-disable-line camelcase\n\nfunction addLooseExports(parse, Parser$$1, plugins$$1) {\n  parse_dammit = parse; // eslint-disable-line camelcase\n\n  LooseParser = Parser$$1;\n  pluginsLoose = plugins$$1;\n}\n\nexport { version, parse, parseExpressionAt, tokenizer, parse_dammit, LooseParser, pluginsLoose, addLooseExports, Parser, plugins, defaultOptions, Position, SourceLocation, getLineInfo, Node, TokenType, types as tokTypes, keywords$1 as keywordTypes, TokContext, types$1 as tokContexts, isIdentifierChar, isIdentifierStart, Token, isNewLine, lineBreak, lineBreakG, nonASCIIwhitespace };"],"sourceRoot":""}